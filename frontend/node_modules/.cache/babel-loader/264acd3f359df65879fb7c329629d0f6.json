{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _possibleConstructorReturn = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Stream = require('stream').Stream;\nvar nmfetch = require('../fetch');\nvar crypto = require('crypto');\nvar shared = require('../shared');\n\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\nvar XOAuth2 = /*#__PURE__*/function (_Stream) {\n  _inherits(XOAuth2, _Stream);\n  var _super = _createSuper(XOAuth2);\n  function XOAuth2(options, logger) {\n    var _this;\n    _classCallCheck(this, XOAuth2);\n    _this = _super.call(this);\n    _this.options = options || {};\n    if (options && options.serviceClient) {\n      if (!options.privateKey || !options.user) {\n        setImmediate(function () {\n          return _this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!'));\n        });\n        return _possibleConstructorReturn(_this);\n      }\n      var serviceRequestTimeout = Math.min(Math.max(Number(_this.options.serviceRequestTimeout) || 0, 0), 3600);\n      _this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n    }\n    _this.logger = shared.getLogger({\n      logger: logger\n    }, {\n      component: _this.options.component || 'OAuth2'\n    });\n    _this.provisionCallback = typeof _this.options.provisionCallback === 'function' ? _this.options.provisionCallback : false;\n    _this.options.accessUrl = _this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n    _this.options.customHeaders = _this.options.customHeaders || {};\n    _this.options.customParams = _this.options.customParams || {};\n    _this.accessToken = _this.options.accessToken || false;\n    if (_this.options.expires && Number(_this.options.expires)) {\n      _this.expires = _this.options.expires;\n    } else {\n      var timeout = Math.max(Number(_this.options.timeout) || 0, 0);\n      _this.expires = timeout && Date.now() + timeout * 1000 || 0;\n    }\n    return _this;\n  }\n\n  /**\n   * Returns or generates (if previous has expired) a XOAuth2 token\n   *\n   * @param {Boolean} renew If false then use cached access token (if available)\n   * @param {Function} callback Callback function with error object and token string\n   */\n  _createClass(XOAuth2, [{\n    key: \"getToken\",\n    value: function getToken(renew, callback) {\n      var _this2 = this;\n      if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n        return callback(null, this.accessToken);\n      }\n      var generateCallback = function generateCallback() {\n        if (arguments.length <= 0 ? undefined : arguments[0]) {\n          _this2.logger.error({\n            err: arguments.length <= 0 ? undefined : arguments[0],\n            tnx: 'OAUTH2',\n            user: _this2.options.user,\n            action: 'renew'\n          }, 'Failed generating new Access Token for %s', _this2.options.user);\n        } else {\n          _this2.logger.info({\n            tnx: 'OAUTH2',\n            user: _this2.options.user,\n            action: 'renew'\n          }, 'Generated new Access Token for %s', _this2.options.user);\n        }\n        callback.apply(void 0, arguments);\n      };\n      if (this.provisionCallback) {\n        this.provisionCallback(this.options.user, !!renew, function (err, accessToken, expires) {\n          if (!err && accessToken) {\n            _this2.accessToken = accessToken;\n            _this2.expires = expires || 0;\n          }\n          generateCallback(err, accessToken);\n        });\n      } else {\n        this.generateToken(generateCallback);\n      }\n    }\n\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(accessToken, timeout) {\n      this.accessToken = accessToken;\n      timeout = Math.max(Number(timeout) || 0, 0);\n      this.expires = timeout && Date.now() + timeout * 1000 || 0;\n      this.emit('token', {\n        user: this.options.user,\n        accessToken: accessToken || '',\n        expires: this.expires\n      });\n    }\n\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n  }, {\n    key: \"generateToken\",\n    value: function generateToken(callback) {\n      var _this3 = this;\n      var urlOptions;\n      var loggedUrlOptions;\n      if (this.options.serviceClient) {\n        // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n        var iat = Math.floor(Date.now() / 1000); // unix time\n        var tokenData = {\n          iss: this.options.serviceClient,\n          scope: this.options.scope || 'https://mail.google.com/',\n          sub: this.options.user,\n          aud: this.options.accessUrl,\n          iat: iat,\n          exp: iat + this.options.serviceRequestTimeout\n        };\n        var token;\n        try {\n          token = this.jwtSignRS256(tokenData);\n        } catch (err) {\n          return callback(new Error('Can\\x27t generate token. Check your auth options'));\n        }\n        urlOptions = {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: token\n        };\n        loggedUrlOptions = {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: tokenData\n        };\n      } else {\n        if (!this.options.refreshToken) {\n          return callback(new Error('Can\\x27t create new access token for user'));\n        }\n\n        // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n        urlOptions = {\n          client_id: this.options.clientId || '',\n          client_secret: this.options.clientSecret || '',\n          refresh_token: this.options.refreshToken,\n          grant_type: 'refresh_token'\n        };\n        loggedUrlOptions = {\n          client_id: this.options.clientId || '',\n          client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n          refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n          grant_type: 'refresh_token'\n        };\n      }\n      Object.keys(this.options.customParams).forEach(function (key) {\n        urlOptions[key] = _this3.options.customParams[key];\n        loggedUrlOptions[key] = _this3.options.customParams[key];\n      });\n      this.logger.debug({\n        tnx: 'OAUTH2',\n        user: this.options.user,\n        action: 'generate'\n      }, 'Requesting token using: %s', JSON.stringify(loggedUrlOptions));\n      this.postRequest(this.options.accessUrl, urlOptions, this.options, function (error, body) {\n        var data;\n        if (error) {\n          return callback(error);\n        }\n        try {\n          data = JSON.parse(body.toString());\n        } catch (E) {\n          return callback(E);\n        }\n        if (!data || typeof data !== 'object') {\n          _this3.logger.debug({\n            tnx: 'OAUTH2',\n            user: _this3.options.user,\n            action: 'post'\n          }, 'Response: %s', (body || '').toString());\n          return callback(new Error('Invalid authentication response'));\n        }\n        var logData = {};\n        Object.keys(data).forEach(function (key) {\n          if (key !== 'access_token') {\n            logData[key] = data[key];\n          } else {\n            logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n          }\n        });\n        _this3.logger.debug({\n          tnx: 'OAUTH2',\n          user: _this3.options.user,\n          action: 'post'\n        }, 'Response: %s', JSON.stringify(logData));\n        if (data.error) {\n          // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n          var errorMessage = data.error;\n          if (data.error_description) {\n            errorMessage += ': ' + data.error_description;\n          }\n          if (data.error_uri) {\n            errorMessage += ' (' + data.error_uri + ')';\n          }\n          return callback(new Error(errorMessage));\n        }\n        if (data.access_token) {\n          _this3.updateToken(data.access_token, data.expires_in);\n          return callback(null, _this3.accessToken);\n        }\n        return callback(new Error('No access token'));\n      });\n    }\n\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n  }, {\n    key: \"buildXOAuth2Token\",\n    value: function buildXOAuth2Token(accessToken) {\n      var authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n      return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows – usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n  }, {\n    key: \"postRequest\",\n    value: function postRequest(url, payload, params, callback) {\n      var returned = false;\n      var chunks = [];\n      var chunklen = 0;\n      var req = nmfetch(url, {\n        method: 'post',\n        headers: params.customHeaders,\n        body: payload,\n        allowErrorResponse: true\n      });\n      req.on('readable', function () {\n        var chunk;\n        while ((chunk = req.read()) !== null) {\n          chunks.push(chunk);\n          chunklen += chunk.length;\n        }\n      });\n      req.once('error', function (err) {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        return callback(err);\n      });\n      req.once('end', function () {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        return callback(null, Buffer.concat(chunks, chunklen));\n      });\n    }\n\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n  }, {\n    key: \"toBase64URL\",\n    value: function toBase64URL(data) {\n      if (typeof data === 'string') {\n        data = Buffer.from(data);\n      }\n      return data.toString('base64').replace(/[=]+/g, '') // remove '='s\n      .replace(/\\+/g, '-') // '+' → '-'\n      .replace(/\\//g, '_'); // '/' → '_'\n    }\n\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n  }, {\n    key: \"jwtSignRS256\",\n    value: function jwtSignRS256(payload) {\n      var _this4 = this;\n      payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(function (val) {\n        return _this4.toBase64URL(val);\n      }).join('.');\n      var signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n      return payload + '.' + this.toBase64URL(signature);\n    }\n  }]);\n  return XOAuth2;\n}(Stream);\nmodule.exports = XOAuth2;","map":{"version":3,"names":["Stream","require","nmfetch","crypto","shared","XOAuth2","options","logger","serviceClient","privateKey","user","setImmediate","emit","Error","serviceRequestTimeout","Math","min","max","Number","getLogger","component","provisionCallback","accessUrl","customHeaders","customParams","accessToken","expires","timeout","Date","now","renew","callback","generateCallback","error","err","tnx","action","info","generateToken","urlOptions","loggedUrlOptions","iat","floor","tokenData","iss","scope","sub","aud","exp","token","jwtSignRS256","grant_type","assertion","refreshToken","client_id","clientId","client_secret","clientSecret","refresh_token","substr","Object","keys","forEach","key","debug","JSON","stringify","postRequest","body","data","parse","toString","E","logData","errorMessage","error_description","error_uri","access_token","updateToken","expires_in","authData","Buffer","from","join","url","payload","params","returned","chunks","chunklen","req","method","headers","allowErrorResponse","on","chunk","read","push","length","once","concat","replace","map","val","toBase64URL","signature","createSign","update","sign","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/xoauth2/index.js"],"sourcesContent":["'use strict';\n\nconst Stream = require('stream').Stream;\nconst nmfetch = require('../fetch');\nconst crypto = require('crypto');\nconst shared = require('../shared');\n\n/**\n * XOAUTH2 access_token generator for Gmail.\n * Create client ID for web applications in Google API console to use it.\n * See Offline Access for receiving the needed refreshToken for an user\n * https://developers.google.com/accounts/docs/OAuth2WebServer#offline\n *\n * Usage for generating access tokens with a custom method using provisionCallback:\n * provisionCallback(user, renew, callback)\n *   * user is the username to get the token for\n *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed\n *   * callback is the callback to run with (error, accessToken [, expires])\n *     * accessToken is a string\n *     * expires is an optional expire time in milliseconds\n * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself\n *\n * @constructor\n * @param {Object} options Client information for token generation\n * @param {String} options.user User e-mail address\n * @param {String} options.clientId Client ID value\n * @param {String} options.clientSecret Client secret value\n * @param {String} options.refreshToken Refresh token for an user\n * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'\n * @param {String} options.accessToken An existing valid accessToken\n * @param {String} options.privateKey Private key for JSW\n * @param {Number} options.expires Optional Access Token expire time in ms\n * @param {Number} options.timeout Optional TTL for Access Token in seconds\n * @param {Function} options.provisionCallback Function to run when a new access token is required\n */\nclass XOAuth2 extends Stream {\n    constructor(options, logger) {\n        super();\n\n        this.options = options || {};\n\n        if (options && options.serviceClient) {\n            if (!options.privateKey || !options.user) {\n                setImmediate(() => this.emit('error', new Error('Options \"privateKey\" and \"user\" are required for service account!')));\n                return;\n            }\n\n            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);\n            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;\n        }\n\n        this.logger = shared.getLogger(\n            {\n                logger\n            },\n            {\n                component: this.options.component || 'OAuth2'\n            }\n        );\n\n        this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;\n\n        this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';\n        this.options.customHeaders = this.options.customHeaders || {};\n        this.options.customParams = this.options.customParams || {};\n\n        this.accessToken = this.options.accessToken || false;\n\n        if (this.options.expires && Number(this.options.expires)) {\n            this.expires = this.options.expires;\n        } else {\n            let timeout = Math.max(Number(this.options.timeout) || 0, 0);\n            this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n        }\n    }\n\n    /**\n     * Returns or generates (if previous has expired) a XOAuth2 token\n     *\n     * @param {Boolean} renew If false then use cached access token (if available)\n     * @param {Function} callback Callback function with error object and token string\n     */\n    getToken(renew, callback) {\n        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {\n            return callback(null, this.accessToken);\n        }\n\n        let generateCallback = (...args) => {\n            if (args[0]) {\n                this.logger.error(\n                    {\n                        err: args[0],\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Failed generating new Access Token for %s',\n                    this.options.user\n                );\n            } else {\n                this.logger.info(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'renew'\n                    },\n                    'Generated new Access Token for %s',\n                    this.options.user\n                );\n            }\n            callback(...args);\n        };\n\n        if (this.provisionCallback) {\n            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {\n                if (!err && accessToken) {\n                    this.accessToken = accessToken;\n                    this.expires = expires || 0;\n                }\n                generateCallback(err, accessToken);\n            });\n        } else {\n            this.generateToken(generateCallback);\n        }\n    }\n\n    /**\n     * Updates token values\n     *\n     * @param {String} accessToken New access token\n     * @param {Number} timeout Access token lifetime in seconds\n     *\n     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}\n     */\n    updateToken(accessToken, timeout) {\n        this.accessToken = accessToken;\n        timeout = Math.max(Number(timeout) || 0, 0);\n        this.expires = (timeout && Date.now() + timeout * 1000) || 0;\n\n        this.emit('token', {\n            user: this.options.user,\n            accessToken: accessToken || '',\n            expires: this.expires\n        });\n    }\n\n    /**\n     * Generates a new XOAuth2 token with the credentials provided at initialization\n     *\n     * @param {Function} callback Callback function with error object and token string\n     */\n    generateToken(callback) {\n        let urlOptions;\n        let loggedUrlOptions;\n        if (this.options.serviceClient) {\n            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount\n            let iat = Math.floor(Date.now() / 1000); // unix time\n            let tokenData = {\n                iss: this.options.serviceClient,\n                scope: this.options.scope || 'https://mail.google.com/',\n                sub: this.options.user,\n                aud: this.options.accessUrl,\n                iat,\n                exp: iat + this.options.serviceRequestTimeout\n            };\n            let token;\n            try {\n                token = this.jwtSignRS256(tokenData);\n            } catch (err) {\n                return callback(new Error('Can\\x27t generate token. Check your auth options'));\n            }\n\n            urlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: token\n            };\n\n            loggedUrlOptions = {\n                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n                assertion: tokenData\n            };\n        } else {\n            if (!this.options.refreshToken) {\n                return callback(new Error('Can\\x27t create new access token for user'));\n            }\n\n            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer\n            urlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: this.options.clientSecret || '',\n                refresh_token: this.options.refreshToken,\n                grant_type: 'refresh_token'\n            };\n\n            loggedUrlOptions = {\n                client_id: this.options.clientId || '',\n                client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',\n                refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',\n                grant_type: 'refresh_token'\n            };\n        }\n\n        Object.keys(this.options.customParams).forEach(key => {\n            urlOptions[key] = this.options.customParams[key];\n            loggedUrlOptions[key] = this.options.customParams[key];\n        });\n\n        this.logger.debug(\n            {\n                tnx: 'OAUTH2',\n                user: this.options.user,\n                action: 'generate'\n            },\n            'Requesting token using: %s',\n            JSON.stringify(loggedUrlOptions)\n        );\n\n        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {\n            let data;\n\n            if (error) {\n                return callback(error);\n            }\n\n            try {\n                data = JSON.parse(body.toString());\n            } catch (E) {\n                return callback(E);\n            }\n\n            if (!data || typeof data !== 'object') {\n                this.logger.debug(\n                    {\n                        tnx: 'OAUTH2',\n                        user: this.options.user,\n                        action: 'post'\n                    },\n                    'Response: %s',\n                    (body || '').toString()\n                );\n                return callback(new Error('Invalid authentication response'));\n            }\n\n            let logData = {};\n            Object.keys(data).forEach(key => {\n                if (key !== 'access_token') {\n                    logData[key] = data[key];\n                } else {\n                    logData[key] = (data[key] || '').toString().substr(0, 6) + '...';\n                }\n            });\n\n            this.logger.debug(\n                {\n                    tnx: 'OAUTH2',\n                    user: this.options.user,\n                    action: 'post'\n                },\n                'Response: %s',\n                JSON.stringify(logData)\n            );\n\n            if (data.error) {\n                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2\n                let errorMessage = data.error;\n                if (data.error_description) {\n                    errorMessage += ': ' + data.error_description;\n                }\n                if (data.error_uri) {\n                    errorMessage += ' (' + data.error_uri + ')';\n                }\n                return callback(new Error(errorMessage));\n            }\n\n            if (data.access_token) {\n                this.updateToken(data.access_token, data.expires_in);\n                return callback(null, this.accessToken);\n            }\n\n            return callback(new Error('No access token'));\n        });\n    }\n\n    /**\n     * Converts an access_token and user id into a base64 encoded XOAuth2 token\n     *\n     * @param {String} [accessToken] Access token string\n     * @return {String} Base64 encoded token for IMAP or SMTP login\n     */\n    buildXOAuth2Token(accessToken) {\n        let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];\n        return Buffer.from(authData.join('\\x01'), 'utf-8').toString('base64');\n    }\n\n    /**\n     * Custom POST request handler.\n     * This is only needed to keep paths short in Windows – usually this module\n     * is a dependency of a dependency and if it tries to require something\n     * like the request module the paths get way too long to handle for Windows.\n     * As we do only a simple POST request we do not actually require complicated\n     * logic support (no redirects, no nothing) anyway.\n     *\n     * @param {String} url Url to POST to\n     * @param {String|Buffer} payload Payload to POST\n     * @param {Function} callback Callback function with (err, buff)\n     */\n    postRequest(url, payload, params, callback) {\n        let returned = false;\n\n        let chunks = [];\n        let chunklen = 0;\n\n        let req = nmfetch(url, {\n            method: 'post',\n            headers: params.customHeaders,\n            body: payload,\n            allowErrorResponse: true\n        });\n\n        req.on('readable', () => {\n            let chunk;\n            while ((chunk = req.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n            }\n        });\n\n        req.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(err);\n        });\n\n        req.once('end', () => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(null, Buffer.concat(chunks, chunklen));\n        });\n    }\n\n    /**\n     * Encodes a buffer or a string into Base64url format\n     *\n     * @param {Buffer|String} data The data to convert\n     * @return {String} The encoded string\n     */\n    toBase64URL(data) {\n        if (typeof data === 'string') {\n            data = Buffer.from(data);\n        }\n\n        return data\n            .toString('base64')\n            .replace(/[=]+/g, '') // remove '='s\n            .replace(/\\+/g, '-') // '+' → '-'\n            .replace(/\\//g, '_'); // '/' → '_'\n    }\n\n    /**\n     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)\n     *\n     * @param {Object} payload The payload to include in the generated token\n     * @return {String} The generated and signed token\n     */\n    jwtSignRS256(payload) {\n        payload = ['{\"alg\":\"RS256\",\"typ\":\"JWT\"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');\n        let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);\n        return payload + '.' + this.toBase64URL(signature);\n    }\n}\n\nmodule.exports = XOAuth2;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}