{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\nfunction encode(buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'utf-8');\n  }\n  return buffer.toString('base64');\n}\n\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\nfunction wrap(str, lineLength) {\n  str = (str || '').toString();\n  lineLength = lineLength || 76;\n  if (str.length <= lineLength) {\n    return str;\n  }\n  var result = [];\n  var pos = 0;\n  var chunkLength = lineLength * 1024;\n  while (pos < str.length) {\n    var wrappedLines = str.substr(pos, chunkLength).replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n').trim();\n    result.push(wrappedLines);\n    pos += chunkLength;\n  }\n  return result.join('\\r\\n').trim();\n}\n\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nvar Encoder = /*#__PURE__*/function (_Transform) {\n  _inherits(Encoder, _Transform);\n  var _super = _createSuper(Encoder);\n  function Encoder(options) {\n    var _this;\n    _classCallCheck(this, Encoder);\n    _this = _super.call(this);\n    // init Transform\n    _this.options = options || {};\n    if (_this.options.lineLength !== false) {\n      _this.options.lineLength = _this.options.lineLength || 76;\n    }\n    _this._curLine = '';\n    _this._remainingBytes = false;\n    _this.inputBytes = 0;\n    _this.outputBytes = 0;\n    return _this;\n  }\n  _createClass(Encoder, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      if (encoding !== 'buffer') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      if (!chunk || !chunk.length) {\n        return setImmediate(done);\n      }\n      this.inputBytes += chunk.length;\n      if (this._remainingBytes && this._remainingBytes.length) {\n        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n        this._remainingBytes = false;\n      }\n      if (chunk.length % 3) {\n        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);\n        chunk = chunk.slice(0, chunk.length - chunk.length % 3);\n      } else {\n        this._remainingBytes = false;\n      }\n      var b64 = this._curLine + encode(chunk);\n      if (this.options.lineLength) {\n        b64 = wrap(b64, this.options.lineLength);\n\n        // remove last line as it is still most probably incomplete\n        var lastLF = b64.lastIndexOf('\\n');\n        if (lastLF < 0) {\n          this._curLine = b64;\n          b64 = '';\n        } else if (lastLF === b64.length - 1) {\n          this._curLine = '';\n        } else {\n          this._curLine = b64.substr(lastLF + 1);\n          b64 = b64.substr(0, lastLF + 1);\n        }\n      }\n      if (b64) {\n        this.outputBytes += b64.length;\n        this.push(Buffer.from(b64, 'ascii'));\n      }\n      setImmediate(done);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      if (this._remainingBytes && this._remainingBytes.length) {\n        this._curLine += encode(this._remainingBytes);\n      }\n      if (this._curLine) {\n        this._curLine = wrap(this._curLine, this.options.lineLength);\n        this.outputBytes += this._curLine.length;\n        this.push(this._curLine, 'ascii');\n        this._curLine = '';\n      }\n      done();\n    }\n  }]);\n  return Encoder;\n}(Transform); // expose to the world\nmodule.exports = {\n  encode: encode,\n  wrap: wrap,\n  Encoder: Encoder\n};","map":{"version":3,"names":["Transform","require","encode","buffer","Buffer","from","toString","wrap","str","lineLength","length","result","pos","chunkLength","wrappedLines","substr","replace","RegExp","trim","push","join","Encoder","options","_curLine","_remainingBytes","inputBytes","outputBytes","chunk","encoding","done","setImmediate","concat","slice","b64","lastLF","lastIndexOf","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/base64/index.js"],"sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * Encodes a Buffer into a base64 encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} base64 encoded string\n */\nfunction encode(buffer) {\n    if (typeof buffer === 'string') {\n        buffer = Buffer.from(buffer, 'utf-8');\n    }\n\n    return buffer.toString('base64');\n}\n\n/**\n * Adds soft line breaks to a base64 string\n *\n * @param {String} str base64 encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped base64 encoded string\n */\nfunction wrap(str, lineLength) {\n    str = (str || '').toString();\n    lineLength = lineLength || 76;\n\n    if (str.length <= lineLength) {\n        return str;\n    }\n\n    let result = [];\n    let pos = 0;\n    let chunkLength = lineLength * 1024;\n    while (pos < str.length) {\n        let wrappedLines = str\n            .substr(pos, chunkLength)\n            .replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\\r\\n')\n            .trim();\n        result.push(wrappedLines);\n        pos += chunkLength;\n    }\n\n    return result.join('\\r\\n').trim();\n}\n\n/**\n * Creates a transform stream for encoding data to base64 encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping\n */\nclass Encoder extends Transform {\n    constructor(options) {\n        super();\n        // init Transform\n        this.options = options || {};\n\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n\n        this._curLine = '';\n        this._remainingBytes = false;\n\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n    }\n\n    _transform(chunk, encoding, done) {\n        if (encoding !== 'buffer') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        if (!chunk || !chunk.length) {\n            return setImmediate(done);\n        }\n\n        this.inputBytes += chunk.length;\n\n        if (this._remainingBytes && this._remainingBytes.length) {\n            chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);\n            this._remainingBytes = false;\n        }\n\n        if (chunk.length % 3) {\n            this._remainingBytes = chunk.slice(chunk.length - (chunk.length % 3));\n            chunk = chunk.slice(0, chunk.length - (chunk.length % 3));\n        } else {\n            this._remainingBytes = false;\n        }\n\n        let b64 = this._curLine + encode(chunk);\n\n        if (this.options.lineLength) {\n            b64 = wrap(b64, this.options.lineLength);\n\n            // remove last line as it is still most probably incomplete\n            let lastLF = b64.lastIndexOf('\\n');\n            if (lastLF < 0) {\n                this._curLine = b64;\n                b64 = '';\n            } else if (lastLF === b64.length - 1) {\n                this._curLine = '';\n            } else {\n                this._curLine = b64.substr(lastLF + 1);\n                b64 = b64.substr(0, lastLF + 1);\n            }\n        }\n\n        if (b64) {\n            this.outputBytes += b64.length;\n            this.push(Buffer.from(b64, 'ascii'));\n        }\n\n        setImmediate(done);\n    }\n\n    _flush(done) {\n        if (this._remainingBytes && this._remainingBytes.length) {\n            this._curLine += encode(this._remainingBytes);\n        }\n\n        if (this._curLine) {\n            this._curLine = wrap(this._curLine, this.options.lineLength);\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, 'ascii');\n            this._curLine = '';\n        }\n        done();\n    }\n}\n\n// expose to the world\nmodule.exports = {\n    encode,\n    wrap,\n    Encoder\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}