{"ast":null,"code":"'use strict';\n\n// streams through a message body and calculates relaxed body hash\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Transform = require('stream').Transform;\nvar crypto = require('crypto');\nvar RelaxedBody = /*#__PURE__*/function (_Transform) {\n  _inherits(RelaxedBody, _Transform);\n  var _super = _createSuper(RelaxedBody);\n  function RelaxedBody(options) {\n    var _this;\n    _classCallCheck(this, RelaxedBody);\n    _this = _super.call(this);\n    options = options || {};\n    _this.chunkBuffer = [];\n    _this.chunkBufferLen = 0;\n    _this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');\n    _this.remainder = '';\n    _this.byteLength = 0;\n    _this.debug = options.debug;\n    _this._debugBody = options.debug ? [] : false;\n    return _this;\n  }\n  _createClass(RelaxedBody, [{\n    key: \"updateHash\",\n    value: function updateHash(chunk) {\n      var bodyStr;\n\n      // find next remainder\n      var nextRemainder = '';\n\n      // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line\n      // If we get another chunk that does not match this description then we can restore the previously processed data\n      var state = 'file';\n      for (var i = chunk.length - 1; i >= 0; i--) {\n        var c = chunk[i];\n        if (state === 'file' && (c === 0x0a || c === 0x0d)) {\n          // do nothing, found \\n or \\r at the end of chunk, stil end of file\n        } else if (state === 'file' && (c === 0x09 || c === 0x20)) {\n          // switch to line ending mode, this is the last non-empty line\n          state = 'line';\n        } else if (state === 'line' && (c === 0x09 || c === 0x20)) {\n          // do nothing, found ' ' or \\t at the end of line, keep processing the last non-empty line\n        } else if (state === 'file' || state === 'line') {\n          // non line/file ending character found, switch to body mode\n          state = 'body';\n          if (i === chunk.length - 1) {\n            // final char is not part of line end or file end, so do nothing\n            break;\n          }\n        }\n        if (i === 0) {\n          // reached to the beginning of the chunk, check if it is still about the ending\n          // and if the remainder also matches\n          if (state === 'file' && (!this.remainder || /[\\r\\n]$/.test(this.remainder)) || state === 'line' && (!this.remainder || /[ \\t]$/.test(this.remainder))) {\n            // keep everything\n            this.remainder += chunk.toString('binary');\n            return;\n          } else if (state === 'line' || state === 'file') {\n            // process existing remainder as normal line but store the current chunk\n            nextRemainder = chunk.toString('binary');\n            chunk = false;\n            break;\n          }\n        }\n        if (state !== 'body') {\n          continue;\n        }\n\n        // reached first non ending byte\n        nextRemainder = chunk.slice(i + 1).toString('binary');\n        chunk = chunk.slice(0, i + 1);\n        break;\n      }\n      var needsFixing = !!this.remainder;\n      if (chunk && !needsFixing) {\n        // check if we even need to change anything\n        for (var _i = 0, len = chunk.length; _i < len; _i++) {\n          if (_i && chunk[_i] === 0x0a && chunk[_i - 1] !== 0x0d) {\n            // missing \\r before \\n\n            needsFixing = true;\n            break;\n          } else if (_i && chunk[_i] === 0x0d && chunk[_i - 1] === 0x20) {\n            // trailing WSP found\n            needsFixing = true;\n            break;\n          } else if (_i && chunk[_i] === 0x20 && chunk[_i - 1] === 0x20) {\n            // multiple spaces found, needs to be replaced with just one\n            needsFixing = true;\n            break;\n          } else if (chunk[_i] === 0x09) {\n            // TAB found, needs to be replaced with a space\n            needsFixing = true;\n            break;\n          }\n        }\n      }\n      if (needsFixing) {\n        bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');\n        this.remainder = nextRemainder;\n        bodyStr = bodyStr.replace(/\\r?\\n/g, '\\n') // use js line endings\n        .replace(/[ \\t]*$/gm, '') // remove line endings, rtrim\n        .replace(/[ \\t]+/gm, ' ') // single spaces\n        .replace(/\\n/g, '\\r\\n'); // restore rfc822 line endings\n        chunk = Buffer.from(bodyStr, 'binary');\n      } else if (nextRemainder) {\n        this.remainder = nextRemainder;\n      }\n      if (this.debug) {\n        this._debugBody.push(chunk);\n      }\n      this.bodyHash.update(chunk);\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (!chunk || !chunk.length) {\n        return callback();\n      }\n      if (typeof chunk === 'string') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      this.updateHash(chunk);\n      this.byteLength += chunk.length;\n      this.push(chunk);\n      callback();\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      // generate final hash and emit it\n      if (/[\\r\\n]$/.test(this.remainder) && this.byteLength > 2) {\n        // add terminating line end\n        this.bodyHash.update(Buffer.from('\\r\\n'));\n      }\n      if (!this.byteLength) {\n        // emit empty line buffer to keep the stream flowing\n        this.push(Buffer.from('\\r\\n'));\n        // this.bodyHash.update(Buffer.from('\\r\\n'));\n      }\n\n      this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);\n      callback();\n    }\n  }]);\n  return RelaxedBody;\n}(Transform);\nmodule.exports = RelaxedBody;","map":{"version":3,"names":["Transform","require","crypto","RelaxedBody","options","chunkBuffer","chunkBufferLen","bodyHash","createHash","hashAlgo","remainder","byteLength","debug","_debugBody","chunk","bodyStr","nextRemainder","state","i","length","c","test","toString","slice","needsFixing","len","replace","Buffer","from","push","update","encoding","callback","updateHash","emit","digest","concat","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/dkim/relaxed-body.js"],"sourcesContent":["'use strict';\n\n// streams through a message body and calculates relaxed body hash\n\nconst Transform = require('stream').Transform;\nconst crypto = require('crypto');\n\nclass RelaxedBody extends Transform {\n    constructor(options) {\n        super();\n        options = options || {};\n        this.chunkBuffer = [];\n        this.chunkBufferLen = 0;\n        this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');\n        this.remainder = '';\n        this.byteLength = 0;\n\n        this.debug = options.debug;\n        this._debugBody = options.debug ? [] : false;\n    }\n\n    updateHash(chunk) {\n        let bodyStr;\n\n        // find next remainder\n        let nextRemainder = '';\n\n        // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line\n        // If we get another chunk that does not match this description then we can restore the previously processed data\n        let state = 'file';\n        for (let i = chunk.length - 1; i >= 0; i--) {\n            let c = chunk[i];\n\n            if (state === 'file' && (c === 0x0a || c === 0x0d)) {\n                // do nothing, found \\n or \\r at the end of chunk, stil end of file\n            } else if (state === 'file' && (c === 0x09 || c === 0x20)) {\n                // switch to line ending mode, this is the last non-empty line\n                state = 'line';\n            } else if (state === 'line' && (c === 0x09 || c === 0x20)) {\n                // do nothing, found ' ' or \\t at the end of line, keep processing the last non-empty line\n            } else if (state === 'file' || state === 'line') {\n                // non line/file ending character found, switch to body mode\n                state = 'body';\n                if (i === chunk.length - 1) {\n                    // final char is not part of line end or file end, so do nothing\n                    break;\n                }\n            }\n\n            if (i === 0) {\n                // reached to the beginning of the chunk, check if it is still about the ending\n                // and if the remainder also matches\n                if (\n                    (state === 'file' && (!this.remainder || /[\\r\\n]$/.test(this.remainder))) ||\n                    (state === 'line' && (!this.remainder || /[ \\t]$/.test(this.remainder)))\n                ) {\n                    // keep everything\n                    this.remainder += chunk.toString('binary');\n                    return;\n                } else if (state === 'line' || state === 'file') {\n                    // process existing remainder as normal line but store the current chunk\n                    nextRemainder = chunk.toString('binary');\n                    chunk = false;\n                    break;\n                }\n            }\n\n            if (state !== 'body') {\n                continue;\n            }\n\n            // reached first non ending byte\n            nextRemainder = chunk.slice(i + 1).toString('binary');\n            chunk = chunk.slice(0, i + 1);\n            break;\n        }\n\n        let needsFixing = !!this.remainder;\n        if (chunk && !needsFixing) {\n            // check if we even need to change anything\n            for (let i = 0, len = chunk.length; i < len; i++) {\n                if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {\n                    // missing \\r before \\n\n                    needsFixing = true;\n                    break;\n                } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {\n                    // trailing WSP found\n                    needsFixing = true;\n                    break;\n                } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {\n                    // multiple spaces found, needs to be replaced with just one\n                    needsFixing = true;\n                    break;\n                } else if (chunk[i] === 0x09) {\n                    // TAB found, needs to be replaced with a space\n                    needsFixing = true;\n                    break;\n                }\n            }\n        }\n\n        if (needsFixing) {\n            bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');\n            this.remainder = nextRemainder;\n            bodyStr = bodyStr\n                .replace(/\\r?\\n/g, '\\n') // use js line endings\n                .replace(/[ \\t]*$/gm, '') // remove line endings, rtrim\n                .replace(/[ \\t]+/gm, ' ') // single spaces\n                .replace(/\\n/g, '\\r\\n'); // restore rfc822 line endings\n            chunk = Buffer.from(bodyStr, 'binary');\n        } else if (nextRemainder) {\n            this.remainder = nextRemainder;\n        }\n\n        if (this.debug) {\n            this._debugBody.push(chunk);\n        }\n        this.bodyHash.update(chunk);\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        this.updateHash(chunk);\n\n        this.byteLength += chunk.length;\n        this.push(chunk);\n        callback();\n    }\n\n    _flush(callback) {\n        // generate final hash and emit it\n        if (/[\\r\\n]$/.test(this.remainder) && this.byteLength > 2) {\n            // add terminating line end\n            this.bodyHash.update(Buffer.from('\\r\\n'));\n        }\n        if (!this.byteLength) {\n            // emit empty line buffer to keep the stream flowing\n            this.push(Buffer.from('\\r\\n'));\n            // this.bodyHash.update(Buffer.from('\\r\\n'));\n        }\n\n        this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);\n        callback();\n    }\n}\n\nmodule.exports = RelaxedBody;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}