{"ast":null,"code":"'use strict';\n\n// FIXME:\n// replace this Transform mess with a method that pipes input argument to output argument\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar MessageParser = require('./message-parser');\nvar RelaxedBody = require('./relaxed-body');\nvar sign = require('./sign');\nvar PassThrough = require('stream').PassThrough;\nvar fs = require('fs');\nvar path = require('path');\nvar crypto = require('crypto');\nvar DKIM_ALGO = 'sha256';\nvar MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk\n\n/*\n// Usage:\n\nlet dkim = new DKIM({\n    domainName: 'example.com',\n    keySelector: 'key-selector',\n    privateKey,\n    cacheDir: '/tmp'\n});\ndkim.sign(input).pipe(process.stdout);\n\n// Where inputStream is a rfc822 message (either a stream, string or Buffer)\n// and outputStream is a DKIM signed rfc822 message\n*/\nvar DKIMSigner = /*#__PURE__*/function () {\n  function DKIMSigner(options, keys, input, output) {\n    var _this = this;\n    _classCallCheck(this, DKIMSigner);\n    this.options = options || {};\n    this.keys = keys;\n    this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;\n    this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;\n    this.cacheDir = this.options.cacheDir || false;\n    this.chunks = [];\n    this.chunklen = 0;\n    this.readPos = 0;\n    this.cachePath = this.cacheDir ? path.join(this.cacheDir, 'message.' + Date.now() + '-' + crypto.randomBytes(14).toString('hex')) : false;\n    this.cache = false;\n    this.headers = false;\n    this.bodyHash = false;\n    this.parser = false;\n    this.relaxedBody = false;\n    this.input = input;\n    this.output = output;\n    this.output.usingCache = false;\n    this.hasErrored = false;\n    this.input.on('error', function (err) {\n      _this.hasErrored = true;\n      _this.cleanup();\n      output.emit('error', err);\n    });\n  }\n  _createClass(DKIMSigner, [{\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (!this.cache || !this.cachePath) {\n        return;\n      }\n      fs.unlink(this.cachePath, function () {\n        return false;\n      });\n    }\n  }, {\n    key: \"createReadCache\",\n    value: function createReadCache() {\n      var _this2 = this;\n      // pipe remainings to cache file\n      this.cache = fs.createReadStream(this.cachePath);\n      this.cache.once('error', function (err) {\n        _this2.cleanup();\n        _this2.output.emit('error', err);\n      });\n      this.cache.once('close', function () {\n        _this2.cleanup();\n      });\n      this.cache.pipe(this.output);\n    }\n  }, {\n    key: \"sendNextChunk\",\n    value: function sendNextChunk() {\n      var _this3 = this;\n      if (this.hasErrored) {\n        return;\n      }\n      if (this.readPos >= this.chunks.length) {\n        if (!this.cache) {\n          return this.output.end();\n        }\n        return this.createReadCache();\n      }\n      var chunk = this.chunks[this.readPos++];\n      if (this.output.write(chunk) === false) {\n        return this.output.once('drain', function () {\n          _this3.sendNextChunk();\n        });\n      }\n      setImmediate(function () {\n        return _this3.sendNextChunk();\n      });\n    }\n  }, {\n    key: \"sendSignedOutput\",\n    value: function sendSignedOutput() {\n      var _this4 = this;\n      var keyPos = 0;\n      var signNextKey = function signNextKey() {\n        if (keyPos >= _this4.keys.length) {\n          _this4.output.write(_this4.parser.rawHeaders);\n          return setImmediate(function () {\n            return _this4.sendNextChunk();\n          });\n        }\n        var key = _this4.keys[keyPos++];\n        var dkimField = sign(_this4.headers, _this4.hashAlgo, _this4.bodyHash, {\n          domainName: key.domainName,\n          keySelector: key.keySelector,\n          privateKey: key.privateKey,\n          headerFieldNames: _this4.options.headerFieldNames,\n          skipFields: _this4.options.skipFields\n        });\n        if (dkimField) {\n          _this4.output.write(Buffer.from(dkimField + '\\r\\n'));\n        }\n        return setImmediate(signNextKey);\n      };\n      if (this.bodyHash && this.headers) {\n        return signNextKey();\n      }\n      this.output.write(this.parser.rawHeaders);\n      this.sendNextChunk();\n    }\n  }, {\n    key: \"createWriteCache\",\n    value: function createWriteCache() {\n      var _this5 = this;\n      this.output.usingCache = true;\n      // pipe remainings to cache file\n      this.cache = fs.createWriteStream(this.cachePath);\n      this.cache.once('error', function (err) {\n        _this5.cleanup();\n        // drain input\n        _this5.relaxedBody.unpipe(_this5.cache);\n        _this5.relaxedBody.on('readable', function () {\n          while (_this5.relaxedBody.read() !== null) {\n            // do nothing\n          }\n        });\n        _this5.hasErrored = true;\n        // emit error\n        _this5.output.emit('error', err);\n      });\n      this.cache.once('close', function () {\n        _this5.sendSignedOutput();\n      });\n      this.relaxedBody.removeAllListeners('readable');\n      this.relaxedBody.pipe(this.cache);\n    }\n  }, {\n    key: \"signStream\",\n    value: function signStream() {\n      var _this6 = this;\n      this.parser = new MessageParser();\n      this.relaxedBody = new RelaxedBody({\n        hashAlgo: this.hashAlgo\n      });\n      this.parser.on('headers', function (value) {\n        _this6.headers = value;\n      });\n      this.relaxedBody.on('hash', function (value) {\n        _this6.bodyHash = value;\n      });\n      this.relaxedBody.on('readable', function () {\n        var chunk;\n        if (_this6.cache) {\n          return;\n        }\n        while ((chunk = _this6.relaxedBody.read()) !== null) {\n          _this6.chunks.push(chunk);\n          _this6.chunklen += chunk.length;\n          if (_this6.chunklen >= _this6.cacheTreshold && _this6.cachePath) {\n            return _this6.createWriteCache();\n          }\n        }\n      });\n      this.relaxedBody.on('end', function () {\n        if (_this6.cache) {\n          return;\n        }\n        _this6.sendSignedOutput();\n      });\n      this.parser.pipe(this.relaxedBody);\n      setImmediate(function () {\n        return _this6.input.pipe(_this6.parser);\n      });\n    }\n  }]);\n  return DKIMSigner;\n}();\nvar DKIM = /*#__PURE__*/function () {\n  function DKIM(options) {\n    _classCallCheck(this, DKIM);\n    this.options = options || {};\n    this.keys = [].concat(this.options.keys || {\n      domainName: options.domainName,\n      keySelector: options.keySelector,\n      privateKey: options.privateKey\n    });\n  }\n  _createClass(DKIM, [{\n    key: \"sign\",\n    value: function sign(input, extraOptions) {\n      var _this7 = this;\n      var output = new PassThrough();\n      var inputStream = input;\n      var writeValue = false;\n      if (Buffer.isBuffer(input)) {\n        writeValue = input;\n        inputStream = new PassThrough();\n      } else if (typeof input === 'string') {\n        writeValue = Buffer.from(input);\n        inputStream = new PassThrough();\n      }\n      var options = this.options;\n      if (extraOptions && Object.keys(extraOptions).length) {\n        options = {};\n        Object.keys(this.options || {}).forEach(function (key) {\n          options[key] = _this7.options[key];\n        });\n        Object.keys(extraOptions || {}).forEach(function (key) {\n          if (!(key in options)) {\n            options[key] = extraOptions[key];\n          }\n        });\n      }\n      var signer = new DKIMSigner(options, this.keys, inputStream, output);\n      setImmediate(function () {\n        signer.signStream();\n        if (writeValue) {\n          setImmediate(function () {\n            inputStream.end(writeValue);\n          });\n        }\n      });\n      return output;\n    }\n  }]);\n  return DKIM;\n}();\nmodule.exports = DKIM;","map":{"version":3,"names":["MessageParser","require","RelaxedBody","sign","PassThrough","fs","path","crypto","DKIM_ALGO","MAX_MESSAGE_SIZE","DKIMSigner","options","keys","input","output","cacheTreshold","Number","hashAlgo","cacheDir","chunks","chunklen","readPos","cachePath","join","Date","now","randomBytes","toString","cache","headers","bodyHash","parser","relaxedBody","usingCache","hasErrored","on","err","cleanup","emit","unlink","createReadStream","once","pipe","length","end","createReadCache","chunk","write","sendNextChunk","setImmediate","keyPos","signNextKey","rawHeaders","key","dkimField","domainName","keySelector","privateKey","headerFieldNames","skipFields","Buffer","from","createWriteStream","unpipe","read","sendSignedOutput","removeAllListeners","value","push","createWriteCache","DKIM","concat","extraOptions","inputStream","writeValue","isBuffer","Object","forEach","signer","signStream","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/dkim/index.js"],"sourcesContent":["'use strict';\n\n// FIXME:\n// replace this Transform mess with a method that pipes input argument to output argument\n\nconst MessageParser = require('./message-parser');\nconst RelaxedBody = require('./relaxed-body');\nconst sign = require('./sign');\nconst PassThrough = require('stream').PassThrough;\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nconst DKIM_ALGO = 'sha256';\nconst MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk\n\n/*\n// Usage:\n\nlet dkim = new DKIM({\n    domainName: 'example.com',\n    keySelector: 'key-selector',\n    privateKey,\n    cacheDir: '/tmp'\n});\ndkim.sign(input).pipe(process.stdout);\n\n// Where inputStream is a rfc822 message (either a stream, string or Buffer)\n// and outputStream is a DKIM signed rfc822 message\n*/\n\nclass DKIMSigner {\n    constructor(options, keys, input, output) {\n        this.options = options || {};\n        this.keys = keys;\n\n        this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;\n        this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;\n\n        this.cacheDir = this.options.cacheDir || false;\n\n        this.chunks = [];\n        this.chunklen = 0;\n        this.readPos = 0;\n        this.cachePath = this.cacheDir ? path.join(this.cacheDir, 'message.' + Date.now() + '-' + crypto.randomBytes(14).toString('hex')) : false;\n        this.cache = false;\n\n        this.headers = false;\n        this.bodyHash = false;\n        this.parser = false;\n        this.relaxedBody = false;\n\n        this.input = input;\n        this.output = output;\n        this.output.usingCache = false;\n\n        this.hasErrored = false;\n\n        this.input.on('error', err => {\n            this.hasErrored = true;\n            this.cleanup();\n            output.emit('error', err);\n        });\n    }\n\n    cleanup() {\n        if (!this.cache || !this.cachePath) {\n            return;\n        }\n        fs.unlink(this.cachePath, () => false);\n    }\n\n    createReadCache() {\n        // pipe remainings to cache file\n        this.cache = fs.createReadStream(this.cachePath);\n        this.cache.once('error', err => {\n            this.cleanup();\n            this.output.emit('error', err);\n        });\n        this.cache.once('close', () => {\n            this.cleanup();\n        });\n        this.cache.pipe(this.output);\n    }\n\n    sendNextChunk() {\n        if (this.hasErrored) {\n            return;\n        }\n\n        if (this.readPos >= this.chunks.length) {\n            if (!this.cache) {\n                return this.output.end();\n            }\n            return this.createReadCache();\n        }\n        let chunk = this.chunks[this.readPos++];\n        if (this.output.write(chunk) === false) {\n            return this.output.once('drain', () => {\n                this.sendNextChunk();\n            });\n        }\n        setImmediate(() => this.sendNextChunk());\n    }\n\n    sendSignedOutput() {\n        let keyPos = 0;\n        let signNextKey = () => {\n            if (keyPos >= this.keys.length) {\n                this.output.write(this.parser.rawHeaders);\n                return setImmediate(() => this.sendNextChunk());\n            }\n            let key = this.keys[keyPos++];\n            let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {\n                domainName: key.domainName,\n                keySelector: key.keySelector,\n                privateKey: key.privateKey,\n                headerFieldNames: this.options.headerFieldNames,\n                skipFields: this.options.skipFields\n            });\n            if (dkimField) {\n                this.output.write(Buffer.from(dkimField + '\\r\\n'));\n            }\n            return setImmediate(signNextKey);\n        };\n\n        if (this.bodyHash && this.headers) {\n            return signNextKey();\n        }\n\n        this.output.write(this.parser.rawHeaders);\n        this.sendNextChunk();\n    }\n\n    createWriteCache() {\n        this.output.usingCache = true;\n        // pipe remainings to cache file\n        this.cache = fs.createWriteStream(this.cachePath);\n        this.cache.once('error', err => {\n            this.cleanup();\n            // drain input\n            this.relaxedBody.unpipe(this.cache);\n            this.relaxedBody.on('readable', () => {\n                while (this.relaxedBody.read() !== null) {\n                    // do nothing\n                }\n            });\n            this.hasErrored = true;\n            // emit error\n            this.output.emit('error', err);\n        });\n        this.cache.once('close', () => {\n            this.sendSignedOutput();\n        });\n        this.relaxedBody.removeAllListeners('readable');\n        this.relaxedBody.pipe(this.cache);\n    }\n\n    signStream() {\n        this.parser = new MessageParser();\n        this.relaxedBody = new RelaxedBody({\n            hashAlgo: this.hashAlgo\n        });\n\n        this.parser.on('headers', value => {\n            this.headers = value;\n        });\n\n        this.relaxedBody.on('hash', value => {\n            this.bodyHash = value;\n        });\n\n        this.relaxedBody.on('readable', () => {\n            let chunk;\n            if (this.cache) {\n                return;\n            }\n            while ((chunk = this.relaxedBody.read()) !== null) {\n                this.chunks.push(chunk);\n                this.chunklen += chunk.length;\n                if (this.chunklen >= this.cacheTreshold && this.cachePath) {\n                    return this.createWriteCache();\n                }\n            }\n        });\n\n        this.relaxedBody.on('end', () => {\n            if (this.cache) {\n                return;\n            }\n            this.sendSignedOutput();\n        });\n\n        this.parser.pipe(this.relaxedBody);\n        setImmediate(() => this.input.pipe(this.parser));\n    }\n}\n\nclass DKIM {\n    constructor(options) {\n        this.options = options || {};\n        this.keys = [].concat(\n            this.options.keys || {\n                domainName: options.domainName,\n                keySelector: options.keySelector,\n                privateKey: options.privateKey\n            }\n        );\n    }\n\n    sign(input, extraOptions) {\n        let output = new PassThrough();\n        let inputStream = input;\n        let writeValue = false;\n\n        if (Buffer.isBuffer(input)) {\n            writeValue = input;\n            inputStream = new PassThrough();\n        } else if (typeof input === 'string') {\n            writeValue = Buffer.from(input);\n            inputStream = new PassThrough();\n        }\n\n        let options = this.options;\n        if (extraOptions && Object.keys(extraOptions).length) {\n            options = {};\n            Object.keys(this.options || {}).forEach(key => {\n                options[key] = this.options[key];\n            });\n            Object.keys(extraOptions || {}).forEach(key => {\n                if (!(key in options)) {\n                    options[key] = extraOptions[key];\n                }\n            });\n        }\n\n        let signer = new DKIMSigner(options, this.keys, inputStream, output);\n        setImmediate(() => {\n            signer.signStream();\n            if (writeValue) {\n                setImmediate(() => {\n                    inputStream.end(writeValue);\n                });\n            }\n        });\n\n        return output;\n    }\n}\n\nmodule.exports = DKIM;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}