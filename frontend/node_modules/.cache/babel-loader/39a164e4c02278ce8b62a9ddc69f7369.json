{"ast":null,"code":"/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar punycode = require('punycode');\nvar PassThrough = require('stream').PassThrough;\nvar shared = require('../shared');\nvar mimeFuncs = require('../mime-funcs');\nvar qp = require('../qp');\nvar base64 = require('../base64');\nvar addressparser = require('../addressparser');\nvar nmfetch = require('../fetch');\nvar LastNewline = require('./last-newline');\nvar LeWindows = require('./le-windows');\nvar LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nvar MimeNode = /*#__PURE__*/function () {\n  function MimeNode(contentType, options) {\n    _classCallCheck(this, MimeNode);\n    this.nodeCounter = 0;\n    options = options || {};\n\n    /**\n     * shared part of the unique multipart boundary\n     */\n    this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n    this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n    this.disableFileAccess = !!options.disableFileAccess;\n    this.disableUrlAccess = !!options.disableUrlAccess;\n    this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n    /**\n     * If date headers is missing and current node is the root, this value is used instead\n     */\n    this.date = new Date();\n\n    /**\n     * Root node for current mime tree\n     */\n    this.rootNode = options.rootNode || this;\n\n    /**\n     * If true include Bcc in generated headers (if available)\n     */\n    this.keepBcc = !!options.keepBcc;\n\n    /**\n     * If filename is specified but contentType is not (probably an attachment)\n     * detect the content type from filename extension\n     */\n    if (options.filename) {\n      /**\n       * Filename for this node. Useful with attachments\n       */\n      this.filename = options.filename;\n      if (!contentType) {\n        contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n      }\n    }\n\n    /**\n     * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n     */\n    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n    /**\n     * Immediate parent for this node (or undefined if not set)\n     */\n    this.parentNode = options.parentNode;\n\n    /**\n     * Hostname for default message-id values\n     */\n    this.hostname = options.hostname;\n\n    /**\n     * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n     */\n    this.newline = options.newline;\n\n    /**\n     * An array for possible child nodes\n     */\n    this.childNodes = [];\n\n    /**\n     * Used for generating unique boundaries (prepended to the shared base)\n     */\n    this._nodeId = ++this.rootNode.nodeCounter;\n\n    /**\n     * A list of header values for this node in the form of [{key:'', value:''}]\n     */\n    this._headers = [];\n\n    /**\n     * True if the content only uses ASCII printable characters\n     * @type {Boolean}\n     */\n    this._isPlainText = false;\n\n    /**\n     * True if the content is plain text but has longer lines than allowed\n     * @type {Boolean}\n     */\n    this._hasLongLines = false;\n\n    /**\n     * If set, use instead this value for envelopes instead of generating one\n     * @type {Boolean}\n     */\n    this._envelope = false;\n\n    /**\n     * If set then use this value as the stream content instead of building it\n     * @type {String|Buffer|Stream}\n     */\n    this._raw = false;\n\n    /**\n     * Additional transform streams that the message will be piped before\n     * exposing by createReadStream\n     * @type {Array}\n     */\n    this._transforms = [];\n\n    /**\n     * Additional process functions that the message will be piped through before\n     * exposing by createReadStream. These functions are run after transforms\n     * @type {Array}\n     */\n    this._processFuncs = [];\n\n    /**\n     * If content type is set (or derived from the filename) add it to headers\n     */\n    if (contentType) {\n      this.setHeader('Content-Type', contentType);\n    }\n  }\n\n  /////// PUBLIC METHODS\n\n  /**\n   * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n   *\n   * @param {String} [contentType] Optional content type\n   * @param {Object} [options] Optional options object\n   * @return {Object} Created node object\n   */\n  _createClass(MimeNode, [{\n    key: \"createChild\",\n    value: function createChild(contentType, options) {\n      if (!options && typeof contentType === 'object') {\n        options = contentType;\n        contentType = undefined;\n      }\n      var node = new MimeNode(contentType, options);\n      this.appendChild(node);\n      return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(childNode) {\n      if (childNode.rootNode !== this.rootNode) {\n        childNode.rootNode = this.rootNode;\n        childNode._nodeId = ++this.rootNode.nodeCounter;\n      }\n      childNode.parentNode = this;\n      this.childNodes.push(childNode);\n      return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n  }, {\n    key: \"replace\",\n    value: function replace(node) {\n      var _this = this;\n      if (node === this) {\n        return this;\n      }\n      this.parentNode.childNodes.forEach(function (childNode, i) {\n        if (childNode === _this) {\n          node.rootNode = _this.rootNode;\n          node.parentNode = _this.parentNode;\n          node._nodeId = _this._nodeId;\n          _this.rootNode = _this;\n          _this.parentNode = undefined;\n          node.parentNode.childNodes[i] = node;\n        }\n      });\n      return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      if (!this.parentNode) {\n        return this;\n      }\n      for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n        if (this.parentNode.childNodes[i] === this) {\n          this.parentNode.childNodes.splice(i, 1);\n          this.parentNode = undefined;\n          this.rootNode = this;\n          return this;\n        }\n      }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(key, value) {\n      var _this2 = this;\n      var added = false,\n        headerValue;\n\n      // Allow setting multiple headers at once\n      if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && 'value' in key) {\n          this.setHeader(key.key, key.value);\n        } else if (Array.isArray(key)) {\n          // allow [{key:'content-type', value: 'text/plain'}]\n          key.forEach(function (i) {\n            _this2.setHeader(i.key, i.value);\n          });\n        } else {\n          // allow {'content-type': 'text/plain'}\n          Object.keys(key).forEach(function (i) {\n            _this2.setHeader(i, key[i]);\n          });\n        }\n        return this;\n      }\n      key = this._normalizeHeaderKey(key);\n      headerValue = {\n        key: key,\n        value: value\n      };\n\n      // Check if the value exists and overwrite\n      for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n          if (!added) {\n            // replace the first match\n            this._headers[i] = headerValue;\n            added = true;\n          } else {\n            // remove following matches\n            this._headers.splice(i, 1);\n            i--;\n            len--;\n          }\n        }\n      }\n\n      // match not found, append the value\n      if (!added) {\n        this._headers.push(headerValue);\n      }\n      return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n  }, {\n    key: \"addHeader\",\n    value: function addHeader(key, value) {\n      var _this3 = this;\n      // Allow setting multiple headers at once\n      if (!value && key && typeof key === 'object') {\n        // allow {key:'content-type', value: 'text/plain'}\n        if (key.key && key.value) {\n          this.addHeader(key.key, key.value);\n        } else if (Array.isArray(key)) {\n          // allow [{key:'content-type', value: 'text/plain'}]\n          key.forEach(function (i) {\n            _this3.addHeader(i.key, i.value);\n          });\n        } else {\n          // allow {'content-type': 'text/plain'}\n          Object.keys(key).forEach(function (i) {\n            _this3.addHeader(i, key[i]);\n          });\n        }\n        return this;\n      } else if (Array.isArray(value)) {\n        value.forEach(function (val) {\n          _this3.addHeader(key, val);\n        });\n        return this;\n      }\n      this._headers.push({\n        key: this._normalizeHeaderKey(key),\n        value: value\n      });\n      return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(key) {\n      key = this._normalizeHeaderKey(key);\n      for (var i = 0, len = this._headers.length; i < len; i++) {\n        if (this._headers[i].key === key) {\n          return this._headers[i].value;\n        }\n      }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n  }, {\n    key: \"setContent\",\n    value: function setContent(content) {\n      var _this4 = this;\n      this.content = content;\n      if (typeof this.content.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n          _this4.content.removeListener('error', _this4._contentErrorHandler);\n          _this4.content = err;\n        };\n        this.content.once('error', this._contentErrorHandler);\n      } else if (typeof this.content === 'string') {\n        this._isPlainText = mimeFuncs.isPlainText(this.content);\n        if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n          // If there are lines longer than 76 symbols/bytes do not use 7bit\n          this._hasLongLines = true;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build(callback) {\n      var promise;\n      if (!callback) {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n      var stream = this.createReadStream();\n      var buf = [];\n      var buflen = 0;\n      var returned = false;\n      stream.on('readable', function () {\n        var chunk;\n        while ((chunk = stream.read()) !== null) {\n          buf.push(chunk);\n          buflen += chunk.length;\n        }\n      });\n      stream.once('error', function (err) {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        return callback(err);\n      });\n      stream.once('end', function (chunk) {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        if (chunk && chunk.length) {\n          buf.push(chunk);\n          buflen += chunk.length;\n        }\n        return callback(null, Buffer.concat(buf, buflen));\n      });\n      return promise;\n    }\n  }, {\n    key: \"getTransferEncoding\",\n    value: function getTransferEncoding() {\n      var transferEncoding = false;\n      var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n      if (this.content) {\n        transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n        if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n          if (/^text\\//i.test(contentType)) {\n            // If there are no special symbols, no need to modify the text\n            if (this._isPlainText && !this._hasLongLines) {\n              transferEncoding = '7bit';\n            } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n              // detect preferred encoding for string value\n              transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n            } else {\n              // we can not check content for a stream, so either use preferred encoding or fallback to QP\n              transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n            }\n          } else if (!/^(multipart|message)\\//i.test(contentType)) {\n            transferEncoding = transferEncoding || 'base64';\n          }\n        }\n      }\n      return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n  }, {\n    key: \"buildHeaders\",\n    value: function buildHeaders() {\n      var _this5 = this;\n      var transferEncoding = this.getTransferEncoding();\n      var headers = [];\n      if (transferEncoding) {\n        this.setHeader('Content-Transfer-Encoding', transferEncoding);\n      }\n      if (this.filename && !this.getHeader('Content-Disposition')) {\n        this.setHeader('Content-Disposition', 'attachment');\n      }\n\n      // Ensure mandatory header fields\n      if (this.rootNode === this) {\n        if (!this.getHeader('Date')) {\n          this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n        }\n\n        // ensure that Message-Id is present\n        this.messageId();\n        if (!this.getHeader('MIME-Version')) {\n          this.setHeader('MIME-Version', '1.0');\n        }\n      }\n      this._headers.forEach(function (header) {\n        var key = header.key;\n        var value = header.value;\n        var structured;\n        var param;\n        var options = {};\n        var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n        if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n          Object.keys(value).forEach(function (key) {\n            if (key !== 'value') {\n              options[key] = value[key];\n            }\n          });\n          value = (value.value || '').toString();\n          if (!value.trim()) {\n            return;\n          }\n        }\n        if (options.prepared) {\n          // header value is\n          if (options.foldLines) {\n            headers.push(mimeFuncs.foldLines(key + ': ' + value));\n          } else {\n            headers.push(key + ': ' + value);\n          }\n          return;\n        }\n        switch (header.key) {\n          case 'Content-Disposition':\n            structured = mimeFuncs.parseHeaderValue(value);\n            if (_this5.filename) {\n              structured.params.filename = _this5.filename;\n            }\n            value = mimeFuncs.buildHeaderValue(structured);\n            break;\n          case 'Content-Type':\n            structured = mimeFuncs.parseHeaderValue(value);\n            _this5._handleContentType(structured);\n            if (structured.value.match(/^text\\/plain\\b/) && typeof _this5.content === 'string' && /[\\u0080-\\uFFFF]/.test(_this5.content)) {\n              structured.params.charset = 'utf-8';\n            }\n            value = mimeFuncs.buildHeaderValue(structured);\n            if (_this5.filename) {\n              // add support for non-compliant clients like QQ webmail\n              // we can't build the value with buildHeaderValue as the value is non standard and\n              // would be converted to parameter continuation encoding that we do not want\n              param = _this5._encodeWords(_this5.filename);\n              if (param !== _this5.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                // include value in quotes if needed\n                param = '\"' + param + '\"';\n              }\n              value += '; name=' + param;\n            }\n            break;\n          case 'Bcc':\n            if (!_this5.keepBcc) {\n              // skip BCC values\n              return;\n            }\n            break;\n        }\n        value = _this5._encodeHeaderValue(key, value);\n\n        // skip empty lines\n        if (!(value || '').toString().trim()) {\n          return;\n        }\n        if (typeof _this5.normalizeHeaderKey === 'function') {\n          var normalized = _this5.normalizeHeaderKey(key, value);\n          if (normalized && typeof normalized === 'string' && normalized.length) {\n            key = normalized;\n          }\n        }\n        headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n      });\n      return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n  }, {\n    key: \"createReadStream\",\n    value: function createReadStream(options) {\n      options = options || {};\n      var stream = new PassThrough(options);\n      var outputStream = stream;\n      var transform;\n      this.stream(stream, options, function (err) {\n        if (err) {\n          outputStream.emit('error', err);\n          return;\n        }\n        stream.end();\n      });\n      for (var i = 0, len = this._transforms.length; i < len; i++) {\n        transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n        outputStream.once('error', function (err) {\n          transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n      }\n\n      // ensure terminating newline after possible user transforms\n      transform = new LastNewline();\n      outputStream.once('error', function (err) {\n        transform.emit('error', err);\n      });\n      outputStream = outputStream.pipe(transform);\n\n      // dkim and stuff\n      for (var _i = 0, _len = this._processFuncs.length; _i < _len; _i++) {\n        transform = this._processFuncs[_i];\n        outputStream = transform(outputStream);\n      }\n      if (this.newline) {\n        var winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n        var newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n        var _stream = outputStream.pipe(newlineTransform);\n        outputStream.on('error', function (err) {\n          return _stream.emit('error', err);\n        });\n        return _stream;\n      }\n      return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n  }, {\n    key: \"transform\",\n    value: function transform(_transform) {\n      this._transforms.push(_transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n  }, {\n    key: \"processFunc\",\n    value: function processFunc(_processFunc) {\n      this._processFuncs.push(_processFunc);\n    }\n  }, {\n    key: \"stream\",\n    value: function stream(outputStream, options, done) {\n      var _this6 = this;\n      var transferEncoding = this.getTransferEncoding();\n      var contentStream;\n      var localStream;\n\n      // protect actual callback against multiple triggering\n      var returned = false;\n      var callback = function callback(err) {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        done(err);\n      };\n\n      // for multipart nodes, push child nodes\n      // for content nodes end the stream\n      var finalize = function finalize() {\n        var childId = 0;\n        var processChildNode = function processChildNode() {\n          if (childId >= _this6.childNodes.length) {\n            outputStream.write('\\r\\n--' + _this6.boundary + '--\\r\\n');\n            return callback();\n          }\n          var child = _this6.childNodes[childId++];\n          outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + _this6.boundary + '\\r\\n');\n          child.stream(outputStream, options, function (err) {\n            if (err) {\n              return callback(err);\n            }\n            setImmediate(processChildNode);\n          });\n        };\n        if (_this6.multipart) {\n          setImmediate(processChildNode);\n        } else {\n          return callback();\n        }\n      };\n\n      // pushes node content\n      var sendContent = function sendContent() {\n        if (_this6.content) {\n          if (Object.prototype.toString.call(_this6.content) === '[object Error]') {\n            // content is already errored\n            return callback(_this6.content);\n          }\n          if (typeof _this6.content.pipe === 'function') {\n            _this6.content.removeListener('error', _this6._contentErrorHandler);\n            _this6._contentErrorHandler = function (err) {\n              return callback(err);\n            };\n            _this6.content.once('error', _this6._contentErrorHandler);\n          }\n          var createStream = function createStream() {\n            if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n              contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n              contentStream.pipe(outputStream, {\n                end: false\n              });\n              contentStream.once('end', finalize);\n              contentStream.once('error', function (err) {\n                return callback(err);\n              });\n              localStream = _this6._getStream(_this6.content);\n              localStream.pipe(contentStream);\n            } else {\n              // anything that is not QP or Base54 passes as-is\n              localStream = _this6._getStream(_this6.content);\n              localStream.pipe(outputStream, {\n                end: false\n              });\n              localStream.once('end', finalize);\n            }\n            localStream.once('error', function (err) {\n              return callback(err);\n            });\n          };\n          if (_this6.content._resolve) {\n            var chunks = [];\n            var chunklen = 0;\n            var _returned = false;\n            var sourceStream = _this6._getStream(_this6.content);\n            sourceStream.on('error', function (err) {\n              if (_returned) {\n                return;\n              }\n              _returned = true;\n              callback(err);\n            });\n            sourceStream.on('readable', function () {\n              var chunk;\n              while ((chunk = sourceStream.read()) !== null) {\n                chunks.push(chunk);\n                chunklen += chunk.length;\n              }\n            });\n            sourceStream.on('end', function () {\n              if (_returned) {\n                return;\n              }\n              _returned = true;\n              _this6.content._resolve = false;\n              _this6.content._resolvedValue = Buffer.concat(chunks, chunklen);\n              setImmediate(createStream);\n            });\n          } else {\n            setImmediate(createStream);\n          }\n          return;\n        } else {\n          return setImmediate(finalize);\n        }\n      };\n      if (this._raw) {\n        setImmediate(function () {\n          if (Object.prototype.toString.call(_this6._raw) === '[object Error]') {\n            // content is already errored\n            return callback(_this6._raw);\n          }\n\n          // remove default error handler (if set)\n          if (typeof _this6._raw.pipe === 'function') {\n            _this6._raw.removeListener('error', _this6._contentErrorHandler);\n          }\n          var raw = _this6._getStream(_this6._raw);\n          raw.pipe(outputStream, {\n            end: false\n          });\n          raw.on('error', function (err) {\n            return outputStream.emit('error', err);\n          });\n          raw.on('end', finalize);\n        });\n      } else {\n        outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n        setImmediate(sendContent);\n      }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n  }, {\n    key: \"setEnvelope\",\n    value: function setEnvelope(envelope) {\n      var _this7 = this;\n      var list;\n      this._envelope = {\n        from: false,\n        to: []\n      };\n      if (envelope.from) {\n        list = [];\n        this._convertAddresses(this._parseAddresses(envelope.from), list);\n        list = list.filter(function (address) {\n          return address && address.address;\n        });\n        if (list.length && list[0]) {\n          this._envelope.from = list[0].address;\n        }\n      }\n      ['to', 'cc', 'bcc'].forEach(function (key) {\n        if (envelope[key]) {\n          _this7._convertAddresses(_this7._parseAddresses(envelope[key]), _this7._envelope.to);\n        }\n      });\n      this._envelope.to = this._envelope.to.map(function (to) {\n        return to.address;\n      }).filter(function (address) {\n        return address;\n      });\n      var standardFields = ['to', 'cc', 'bcc', 'from'];\n      Object.keys(envelope).forEach(function (key) {\n        if (!standardFields.includes(key)) {\n          _this7._envelope[key] = envelope[key];\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n  }, {\n    key: \"getAddresses\",\n    value: function getAddresses() {\n      var _this8 = this;\n      var addresses = {};\n      this._headers.forEach(function (header) {\n        var key = header.key.toLowerCase();\n        if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n          if (!Array.isArray(addresses[key])) {\n            addresses[key] = [];\n          }\n          _this8._convertAddresses(_this8._parseAddresses(header.value), addresses[key]);\n        }\n      });\n      return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n  }, {\n    key: \"getEnvelope\",\n    value: function getEnvelope() {\n      var _this9 = this;\n      if (this._envelope) {\n        return this._envelope;\n      }\n      var envelope = {\n        from: false,\n        to: []\n      };\n      this._headers.forEach(function (header) {\n        var list = [];\n        if (header.key === 'From' || !envelope.from && ['Reply-To', 'Sender'].includes(header.key)) {\n          _this9._convertAddresses(_this9._parseAddresses(header.value), list);\n          if (list.length && list[0]) {\n            envelope.from = list[0].address;\n          }\n        } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n          _this9._convertAddresses(_this9._parseAddresses(header.value), envelope.to);\n        }\n      });\n      envelope.to = envelope.to.map(function (to) {\n        return to.address;\n      });\n      return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n  }, {\n    key: \"messageId\",\n    value: function messageId() {\n      var messageId = this.getHeader('Message-ID');\n      // You really should define your own Message-Id field!\n      if (!messageId) {\n        messageId = this._generateMessageId();\n        this.setHeader('Message-ID', messageId);\n      }\n      return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n  }, {\n    key: \"setRaw\",\n    value: function setRaw(raw) {\n      var _this10 = this;\n      this._raw = raw;\n      if (this._raw && typeof this._raw.pipe === 'function') {\n        // pre-stream handler. might be triggered if a stream is set as content\n        // and 'error' fires before anything is done with this stream\n        this._contentErrorHandler = function (err) {\n          _this10._raw.removeListener('error', _this10._contentErrorHandler);\n          _this10._raw = err;\n        };\n        this._raw.once('error', this._contentErrorHandler);\n      }\n      return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n  }, {\n    key: \"_getStream\",\n    value: function _getStream(content) {\n      var contentStream;\n      if (content._resolvedValue) {\n        // pass string or buffer content as a stream\n        contentStream = new PassThrough();\n        setImmediate(function () {\n          return contentStream.end(content._resolvedValue);\n        });\n        return contentStream;\n      } else if (typeof content.pipe === 'function') {\n        // assume as stream\n        return content;\n      } else if (content && typeof content.path === 'string' && !content.href) {\n        if (this.disableFileAccess) {\n          contentStream = new PassThrough();\n          setImmediate(function () {\n            return contentStream.emit('error', new Error('File access rejected for ' + content.path));\n          });\n          return contentStream;\n        }\n        // read file\n        return fs.createReadStream(content.path);\n      } else if (content && typeof content.href === 'string') {\n        if (this.disableUrlAccess) {\n          contentStream = new PassThrough();\n          setImmediate(function () {\n            return contentStream.emit('error', new Error('Url access rejected for ' + content.href));\n          });\n          return contentStream;\n        }\n        // fetch URL\n        return nmfetch(content.href, {\n          headers: content.httpHeaders\n        });\n      } else {\n        // pass string or buffer content as a stream\n        contentStream = new PassThrough();\n        setImmediate(function () {\n          return contentStream.end(content || '');\n        });\n        return contentStream;\n      }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n  }, {\n    key: \"_parseAddresses\",\n    value: function _parseAddresses(addresses) {\n      var _this11 = this;\n      return [].concat.apply([], [].concat(addresses).map(function (address) {\n        // eslint-disable-line prefer-spread\n        if (address && address.address) {\n          address.address = _this11._normalizeAddress(address.address);\n          address.name = address.name || '';\n          return [address];\n        }\n        return addressparser(address);\n      }));\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n  }, {\n    key: \"_normalizeHeaderKey\",\n    value: function _normalizeHeaderKey(key) {\n      key = (key || '').toString()\n      // no newlines in keys\n      .replace(/\\r?\\n|\\r/g, ' ').trim().toLowerCase()\n      // use uppercase words, except MIME\n      .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, function (c) {\n        return c.toUpperCase();\n      })\n      // special case\n      .replace(/^Content-Features$/i, 'Content-features');\n      return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n  }, {\n    key: \"_handleContentType\",\n    value: function _handleContentType(structured) {\n      this.contentType = structured.value.trim().toLowerCase();\n      this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n      if (this.multipart) {\n        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n      } else {\n        this.boundary = false;\n      }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n  }, {\n    key: \"_generateBoundary\",\n    value: function _generateBoundary() {\n      return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n  }, {\n    key: \"_encodeHeaderValue\",\n    value: function _encodeHeaderValue(key, value) {\n      key = this._normalizeHeaderKey(key);\n      switch (key) {\n        // Structured headers\n        case 'From':\n        case 'Sender':\n        case 'To':\n        case 'Cc':\n        case 'Bcc':\n        case 'Reply-To':\n          return this._convertAddresses(this._parseAddresses(value));\n\n        // values enclosed in <>\n        case 'Message-ID':\n        case 'In-Reply-To':\n        case 'Content-Id':\n          value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n          if (value.charAt(0) !== '<') {\n            value = '<' + value;\n          }\n          if (value.charAt(value.length - 1) !== '>') {\n            value = value + '>';\n          }\n          return value;\n\n        // space separated list of values enclosed in <>\n        case 'References':\n          value = [].concat.apply([], [].concat(value || '').map(function (elm) {\n            // eslint-disable-line prefer-spread\n            elm = (elm || '').toString().replace(/\\r?\\n|\\r/g, ' ').trim();\n            return elm.replace(/<[^>]*>/g, function (str) {\n              return str.replace(/\\s/g, '');\n            }).split(/\\s+/);\n          })).map(function (elm) {\n            if (elm.charAt(0) !== '<') {\n              elm = '<' + elm;\n            }\n            if (elm.charAt(elm.length - 1) !== '>') {\n              elm = elm + '>';\n            }\n            return elm;\n          });\n          return value.join(' ').trim();\n        case 'Date':\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return value.toUTCString().replace(/GMT/, '+0000');\n          }\n          value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n          return this._encodeWords(value);\n        case 'Content-Type':\n        case 'Content-Disposition':\n          // if it includes a filename then it is already encoded\n          return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n        default:\n          value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n          // encodeWords only encodes if needed, otherwise the original string is returned\n          return this._encodeWords(value);\n      }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n  }, {\n    key: \"_convertAddresses\",\n    value: function _convertAddresses(addresses, uniqueList) {\n      var _this12 = this;\n      var values = [];\n      uniqueList = uniqueList || [];\n      [].concat(addresses || []).forEach(function (address) {\n        if (address.address) {\n          address.address = _this12._normalizeAddress(address.address);\n          if (!address.name) {\n            values.push(address.address.indexOf(' ') >= 0 ? \"<\".concat(address.address, \">\") : \"\".concat(address.address));\n          } else if (address.name) {\n            values.push(\"\".concat(_this12._encodeAddressName(address.name), \" <\").concat(address.address, \">\"));\n          }\n          if (address.address) {\n            if (!uniqueList.filter(function (a) {\n              return a.address === address.address;\n            }).length) {\n              uniqueList.push(address);\n            }\n          }\n        } else if (address.group) {\n          var groupListAddresses = (address.group.length ? _this12._convertAddresses(address.group, uniqueList) : '').trim();\n          values.push(\"\".concat(_this12._encodeAddressName(address.name), \":\").concat(groupListAddresses, \";\"));\n        }\n      });\n      return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n  }, {\n    key: \"_normalizeAddress\",\n    value: function _normalizeAddress(address) {\n      address = (address || '').toString().replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n      .trim();\n      var lastAt = address.lastIndexOf('@');\n      if (lastAt < 0) {\n        // Bare username\n        return address;\n      }\n      var user = address.substr(0, lastAt);\n      var domain = address.substr(lastAt + 1);\n\n      // Usernames are not touched and are kept as is even if these include unicode\n      // Domains are punycoded by default\n      // 'jÃµgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n      // non-unicode domains are left as is\n\n      var encodedDomain;\n      try {\n        encodedDomain = punycode.toASCII(domain.toLowerCase());\n      } catch (err) {\n        // keep as is?\n      }\n      if (user.indexOf(' ') >= 0) {\n        if (user.charAt(0) !== '\"') {\n          user = '\"' + user;\n        }\n        if (user.substr(-1) !== '\"') {\n          user = user + '\"';\n        }\n      }\n      return \"\".concat(user, \"@\").concat(encodedDomain);\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n  }, {\n    key: \"_encodeAddressName\",\n    value: function _encodeAddressName(name) {\n      if (!/^[\\w ']*$/.test(name)) {\n        if (/^[\\x20-\\x7e]*$/.test(name)) {\n          return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n        } else {\n          return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n        }\n      }\n      return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n  }, {\n    key: \"_encodeWords\",\n    value: function _encodeWords(value) {\n      // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n      // by default only words that include non-ascii should be converted into encoded words\n      // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n      return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n  }, {\n    key: \"_getTextEncoding\",\n    value: function _getTextEncoding(value) {\n      value = (value || '').toString();\n      var encoding = this.textEncoding;\n      var latinLen;\n      var nonLatinLen;\n      if (!encoding) {\n        // count latin alphabet symbols and 8-bit range symbols + control symbols\n        // if there are more latin characters, then use quoted-printable\n        // encoding, otherwise use base64\n        nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n        latinLen = (value.match(/[a-z]/gi) || []).length;\n        // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n        encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n      }\n      return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n  }, {\n    key: \"_generateMessageId\",\n    value: function _generateMessageId() {\n      return '<' + [2, 2, 2, 6].reduce(\n      // crux to generate UUID-like random strings\n      function (prev, len) {\n        return prev + '-' + crypto.randomBytes(len).toString('hex');\n      }, crypto.randomBytes(4).toString('hex')) + '@' +\n      // try to use the domain of the FROM address or fallback to server hostname\n      (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() + '>';\n    }\n  }]);\n  return MimeNode;\n}();\nmodule.exports = MimeNode;","map":{"version":3,"names":["crypto","require","fs","punycode","PassThrough","shared","mimeFuncs","qp","base64","addressparser","nmfetch","LastNewline","LeWindows","LeUnix","MimeNode","contentType","options","nodeCounter","baseBoundary","randomBytes","toString","boundaryPrefix","disableFileAccess","disableUrlAccess","normalizeHeaderKey","date","Date","rootNode","keepBcc","filename","detectMimeType","split","pop","textEncoding","trim","charAt","toUpperCase","parentNode","hostname","newline","childNodes","_nodeId","_headers","_isPlainText","_hasLongLines","_envelope","_raw","_transforms","_processFuncs","setHeader","undefined","node","appendChild","childNode","push","forEach","i","length","splice","key","value","added","headerValue","Array","isArray","Object","keys","_normalizeHeaderKey","len","addHeader","val","content","pipe","_contentErrorHandler","err","removeListener","once","isPlainText","hasLongerLines","callback","promise","Promise","resolve","reject","callbackPromise","stream","createReadStream","buf","buflen","returned","on","chunk","read","Buffer","concat","transferEncoding","getHeader","toLowerCase","includes","test","_getTextEncoding","getTransferEncoding","headers","toUTCString","replace","messageId","header","structured","param","formattedHeaders","prepared","foldLines","parseHeaderValue","params","buildHeaderValue","_handleContentType","match","charset","_encodeWords","_encodeHeaderValue","normalized","join","outputStream","transform","emit","end","winbreak","newlineTransform","processFunc","done","contentStream","localStream","finalize","childId","processChildNode","write","boundary","child","setImmediate","multipart","sendContent","prototype","call","createStream","Encoder","_getStream","_resolve","chunks","chunklen","sourceStream","_resolvedValue","raw","buildHeaders","envelope","list","from","to","_convertAddresses","_parseAddresses","filter","address","map","standardFields","addresses","_generateMessageId","path","href","Error","httpHeaders","apply","_normalizeAddress","name","c","substr","indexOf","_generateBoundary","elm","str","uniqueList","values","_encodeAddressName","a","group","groupListAddresses","lastAt","lastIndexOf","user","domain","encodedDomain","toASCII","encodeWord","encodeWords","encoding","latinLen","nonLatinLen","reduce","prev","getEnvelope","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/mime-node/index.js"],"sourcesContent":["/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */\n\n'use strict';\n\nconst crypto = require('crypto');\nconst fs = require('fs');\nconst punycode = require('punycode');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\nconst mimeFuncs = require('../mime-funcs');\nconst qp = require('../qp');\nconst base64 = require('../base64');\nconst addressparser = require('../addressparser');\nconst nmfetch = require('../fetch');\nconst LastNewline = require('./last-newline');\n\nconst LeWindows = require('./le-windows');\nconst LeUnix = require('./le-unix');\n\n/**\n * Creates a new mime tree node. Assumes 'multipart/*' as the content type\n * if it is a branch, anything else counts as leaf. If rootNode is missing from\n * the options, assumes this is the root.\n *\n * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)\n * @param {Object} [options] optional options\n * @param {Object} [options.rootNode] root node for this tree\n * @param {Object} [options.parentNode] immediate parent for this node\n * @param {Object} [options.filename] filename for an attachment node\n * @param {String} [options.baseBoundary] shared part of the unique multipart boundary\n * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers\n * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing\n * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'\n */\nclass MimeNode {\n    constructor(contentType, options) {\n        this.nodeCounter = 0;\n\n        options = options || {};\n\n        /**\n         * shared part of the unique multipart boundary\n         */\n        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');\n        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';\n\n        this.disableFileAccess = !!options.disableFileAccess;\n        this.disableUrlAccess = !!options.disableUrlAccess;\n\n        this.normalizeHeaderKey = options.normalizeHeaderKey;\n\n        /**\n         * If date headers is missing and current node is the root, this value is used instead\n         */\n        this.date = new Date();\n\n        /**\n         * Root node for current mime tree\n         */\n        this.rootNode = options.rootNode || this;\n\n        /**\n         * If true include Bcc in generated headers (if available)\n         */\n        this.keepBcc = !!options.keepBcc;\n\n        /**\n         * If filename is specified but contentType is not (probably an attachment)\n         * detect the content type from filename extension\n         */\n        if (options.filename) {\n            /**\n             * Filename for this node. Useful with attachments\n             */\n            this.filename = options.filename;\n            if (!contentType) {\n                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());\n            }\n        }\n\n        /**\n         * Indicates which encoding should be used for header strings: \"Q\" or \"B\"\n         */\n        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();\n\n        /**\n         * Immediate parent for this node (or undefined if not set)\n         */\n        this.parentNode = options.parentNode;\n\n        /**\n         * Hostname for default message-id values\n         */\n        this.hostname = options.hostname;\n\n        /**\n         * If set to 'win' then uses \\r\\n, if 'linux' then \\n. If not set (or `raw` is used) then newlines are kept as is.\n         */\n        this.newline = options.newline;\n\n        /**\n         * An array for possible child nodes\n         */\n        this.childNodes = [];\n\n        /**\n         * Used for generating unique boundaries (prepended to the shared base)\n         */\n        this._nodeId = ++this.rootNode.nodeCounter;\n\n        /**\n         * A list of header values for this node in the form of [{key:'', value:''}]\n         */\n        this._headers = [];\n\n        /**\n         * True if the content only uses ASCII printable characters\n         * @type {Boolean}\n         */\n        this._isPlainText = false;\n\n        /**\n         * True if the content is plain text but has longer lines than allowed\n         * @type {Boolean}\n         */\n        this._hasLongLines = false;\n\n        /**\n         * If set, use instead this value for envelopes instead of generating one\n         * @type {Boolean}\n         */\n        this._envelope = false;\n\n        /**\n         * If set then use this value as the stream content instead of building it\n         * @type {String|Buffer|Stream}\n         */\n        this._raw = false;\n\n        /**\n         * Additional transform streams that the message will be piped before\n         * exposing by createReadStream\n         * @type {Array}\n         */\n        this._transforms = [];\n\n        /**\n         * Additional process functions that the message will be piped through before\n         * exposing by createReadStream. These functions are run after transforms\n         * @type {Array}\n         */\n        this._processFuncs = [];\n\n        /**\n         * If content type is set (or derived from the filename) add it to headers\n         */\n        if (contentType) {\n            this.setHeader('Content-Type', contentType);\n        }\n    }\n\n    /////// PUBLIC METHODS\n\n    /**\n     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor\n     *\n     * @param {String} [contentType] Optional content type\n     * @param {Object} [options] Optional options object\n     * @return {Object} Created node object\n     */\n    createChild(contentType, options) {\n        if (!options && typeof contentType === 'object') {\n            options = contentType;\n            contentType = undefined;\n        }\n        let node = new MimeNode(contentType, options);\n        this.appendChild(node);\n        return node;\n    }\n\n    /**\n     * Appends an existing node to the mime tree. Removes the node from an existing\n     * tree if needed\n     *\n     * @param {Object} childNode node to be appended\n     * @return {Object} Appended node object\n     */\n    appendChild(childNode) {\n        if (childNode.rootNode !== this.rootNode) {\n            childNode.rootNode = this.rootNode;\n            childNode._nodeId = ++this.rootNode.nodeCounter;\n        }\n\n        childNode.parentNode = this;\n\n        this.childNodes.push(childNode);\n        return childNode;\n    }\n\n    /**\n     * Replaces current node with another node\n     *\n     * @param {Object} node Replacement node\n     * @return {Object} Replacement node\n     */\n    replace(node) {\n        if (node === this) {\n            return this;\n        }\n\n        this.parentNode.childNodes.forEach((childNode, i) => {\n            if (childNode === this) {\n                node.rootNode = this.rootNode;\n                node.parentNode = this.parentNode;\n                node._nodeId = this._nodeId;\n\n                this.rootNode = this;\n                this.parentNode = undefined;\n\n                node.parentNode.childNodes[i] = node;\n            }\n        });\n\n        return node;\n    }\n\n    /**\n     * Removes current node from the mime tree\n     *\n     * @return {Object} removed node\n     */\n    remove() {\n        if (!this.parentNode) {\n            return this;\n        }\n\n        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {\n            if (this.parentNode.childNodes[i] === this) {\n                this.parentNode.childNodes.splice(i, 1);\n                this.parentNode = undefined;\n                this.rootNode = this;\n                return this;\n            }\n        }\n    }\n\n    /**\n     * Sets a header value. If the value for selected key exists, it is overwritten.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    setHeader(key, value) {\n        let added = false,\n            headerValue;\n\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && 'value' in key) {\n                this.setHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.setHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.setHeader(i, key[i]);\n                });\n            }\n            return this;\n        }\n\n        key = this._normalizeHeaderKey(key);\n\n        headerValue = {\n            key,\n            value\n        };\n\n        // Check if the value exists and overwrite\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                if (!added) {\n                    // replace the first match\n                    this._headers[i] = headerValue;\n                    added = true;\n                } else {\n                    // remove following matches\n                    this._headers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n\n        // match not found, append the value\n        if (!added) {\n            this._headers.push(headerValue);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a header value. If the value for selected key exists, the value is appended\n     * as a new field and old one is not touched.\n     * You can set multiple values as well by using [{key:'', value:''}] or\n     * {key: 'value'} as the first argument.\n     *\n     * @param {String|Array|Object} key Header key or a list of key value pairs\n     * @param {String} value Header value\n     * @return {Object} current node\n     */\n    addHeader(key, value) {\n        // Allow setting multiple headers at once\n        if (!value && key && typeof key === 'object') {\n            // allow {key:'content-type', value: 'text/plain'}\n            if (key.key && key.value) {\n                this.addHeader(key.key, key.value);\n            } else if (Array.isArray(key)) {\n                // allow [{key:'content-type', value: 'text/plain'}]\n                key.forEach(i => {\n                    this.addHeader(i.key, i.value);\n                });\n            } else {\n                // allow {'content-type': 'text/plain'}\n                Object.keys(key).forEach(i => {\n                    this.addHeader(i, key[i]);\n                });\n            }\n            return this;\n        } else if (Array.isArray(value)) {\n            value.forEach(val => {\n                this.addHeader(key, val);\n            });\n            return this;\n        }\n\n        this._headers.push({\n            key: this._normalizeHeaderKey(key),\n            value\n        });\n\n        return this;\n    }\n\n    /**\n     * Retrieves the first mathcing value of a selected key\n     *\n     * @param {String} key Key to search for\n     * @retun {String} Value for the key\n     */\n    getHeader(key) {\n        key = this._normalizeHeaderKey(key);\n        for (let i = 0, len = this._headers.length; i < len; i++) {\n            if (this._headers[i].key === key) {\n                return this._headers[i].value;\n            }\n        }\n    }\n\n    /**\n     * Sets body content for current node. If the value is a string, charset is added automatically\n     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify\n     * the charset yourself\n     *\n     * @param (String|Buffer) content Body content\n     * @return {Object} current node\n     */\n    setContent(content) {\n        this.content = content;\n        if (typeof this.content.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this.content.removeListener('error', this._contentErrorHandler);\n                this.content = err;\n            };\n            this.content.once('error', this._contentErrorHandler);\n        } else if (typeof this.content === 'string') {\n            this._isPlainText = mimeFuncs.isPlainText(this.content);\n            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {\n                // If there are lines longer than 76 symbols/bytes do not use 7bit\n                this._hasLongLines = true;\n            }\n        }\n        return this;\n    }\n\n    build(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let stream = this.createReadStream();\n        let buf = [];\n        let buflen = 0;\n        let returned = false;\n\n        stream.on('readable', () => {\n            let chunk;\n\n            while ((chunk = stream.read()) !== null) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n        });\n\n        stream.once('error', err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            return callback(err);\n        });\n\n        stream.once('end', chunk => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            if (chunk && chunk.length) {\n                buf.push(chunk);\n                buflen += chunk.length;\n            }\n            return callback(null, Buffer.concat(buf, buflen));\n        });\n\n        return promise;\n    }\n\n    getTransferEncoding() {\n        let transferEncoding = false;\n        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();\n\n        if (this.content) {\n            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();\n            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {\n                if (/^text\\//i.test(contentType)) {\n                    // If there are no special symbols, no need to modify the text\n                    if (this._isPlainText && !this._hasLongLines) {\n                        transferEncoding = '7bit';\n                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {\n                        // detect preferred encoding for string value\n                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';\n                    } else {\n                        // we can not check content for a stream, so either use preferred encoding or fallback to QP\n                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';\n                    }\n                } else if (!/^(multipart|message)\\//i.test(contentType)) {\n                    transferEncoding = transferEncoding || 'base64';\n                }\n            }\n        }\n        return transferEncoding;\n    }\n\n    /**\n     * Builds the header block for the mime node. Append \\r\\n\\r\\n before writing the content\n     *\n     * @returns {String} Headers\n     */\n    buildHeaders() {\n        let transferEncoding = this.getTransferEncoding();\n        let headers = [];\n\n        if (transferEncoding) {\n            this.setHeader('Content-Transfer-Encoding', transferEncoding);\n        }\n\n        if (this.filename && !this.getHeader('Content-Disposition')) {\n            this.setHeader('Content-Disposition', 'attachment');\n        }\n\n        // Ensure mandatory header fields\n        if (this.rootNode === this) {\n            if (!this.getHeader('Date')) {\n                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));\n            }\n\n            // ensure that Message-Id is present\n            this.messageId();\n\n            if (!this.getHeader('MIME-Version')) {\n                this.setHeader('MIME-Version', '1.0');\n            }\n        }\n\n        this._headers.forEach(header => {\n            let key = header.key;\n            let value = header.value;\n            let structured;\n            let param;\n            let options = {};\n            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];\n\n            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {\n                Object.keys(value).forEach(key => {\n                    if (key !== 'value') {\n                        options[key] = value[key];\n                    }\n                });\n                value = (value.value || '').toString();\n                if (!value.trim()) {\n                    return;\n                }\n            }\n\n            if (options.prepared) {\n                // header value is\n                if (options.foldLines) {\n                    headers.push(mimeFuncs.foldLines(key + ': ' + value));\n                } else {\n                    headers.push(key + ': ' + value);\n                }\n                return;\n            }\n\n            switch (header.key) {\n                case 'Content-Disposition':\n                    structured = mimeFuncs.parseHeaderValue(value);\n                    if (this.filename) {\n                        structured.params.filename = this.filename;\n                    }\n                    value = mimeFuncs.buildHeaderValue(structured);\n                    break;\n\n                case 'Content-Type':\n                    structured = mimeFuncs.parseHeaderValue(value);\n\n                    this._handleContentType(structured);\n\n                    if (structured.value.match(/^text\\/plain\\b/) && typeof this.content === 'string' && /[\\u0080-\\uFFFF]/.test(this.content)) {\n                        structured.params.charset = 'utf-8';\n                    }\n\n                    value = mimeFuncs.buildHeaderValue(structured);\n\n                    if (this.filename) {\n                        // add support for non-compliant clients like QQ webmail\n                        // we can't build the value with buildHeaderValue as the value is non standard and\n                        // would be converted to parameter continuation encoding that we do not want\n                        param = this._encodeWords(this.filename);\n\n                        if (param !== this.filename || /[\\s'\"\\\\;:/=(),<>@[\\]?]|^-/.test(param)) {\n                            // include value in quotes if needed\n                            param = '\"' + param + '\"';\n                        }\n                        value += '; name=' + param;\n                    }\n                    break;\n\n                case 'Bcc':\n                    if (!this.keepBcc) {\n                        // skip BCC values\n                        return;\n                    }\n                    break;\n            }\n\n            value = this._encodeHeaderValue(key, value);\n\n            // skip empty lines\n            if (!(value || '').toString().trim()) {\n                return;\n            }\n\n            if (typeof this.normalizeHeaderKey === 'function') {\n                let normalized = this.normalizeHeaderKey(key, value);\n                if (normalized && typeof normalized === 'string' && normalized.length) {\n                    key = normalized;\n                }\n            }\n\n            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));\n        });\n\n        return headers.join('\\r\\n');\n    }\n\n    /**\n     * Streams the rfc2822 message from the current node. If this is a root node,\n     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)\n     *\n     * @return {String} Compiled message\n     */\n    createReadStream(options) {\n        options = options || {};\n\n        let stream = new PassThrough(options);\n        let outputStream = stream;\n        let transform;\n\n        this.stream(stream, options, err => {\n            if (err) {\n                outputStream.emit('error', err);\n                return;\n            }\n            stream.end();\n        });\n\n        for (let i = 0, len = this._transforms.length; i < len; i++) {\n            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];\n            outputStream.once('error', err => {\n                transform.emit('error', err);\n            });\n            outputStream = outputStream.pipe(transform);\n        }\n\n        // ensure terminating newline after possible user transforms\n        transform = new LastNewline();\n        outputStream.once('error', err => {\n            transform.emit('error', err);\n        });\n        outputStream = outputStream.pipe(transform);\n\n        // dkim and stuff\n        for (let i = 0, len = this._processFuncs.length; i < len; i++) {\n            transform = this._processFuncs[i];\n            outputStream = transform(outputStream);\n        }\n\n        if (this.newline) {\n            const winbreak = ['win', 'windows', 'dos', '\\r\\n'].includes(this.newline.toString().toLowerCase());\n            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();\n\n            const stream = outputStream.pipe(newlineTransform);\n            outputStream.on('error', err => stream.emit('error', err));\n            return stream;\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * Appends a transform stream object to the transforms list. Final output\n     * is passed through this stream before exposing\n     *\n     * @param {Object} transform Read-Write stream\n     */\n    transform(transform) {\n        this._transforms.push(transform);\n    }\n\n    /**\n     * Appends a post process function. The functon is run after transforms and\n     * uses the following syntax\n     *\n     *   processFunc(input) -> outputStream\n     *\n     * @param {Object} processFunc Read-Write stream\n     */\n    processFunc(processFunc) {\n        this._processFuncs.push(processFunc);\n    }\n\n    stream(outputStream, options, done) {\n        let transferEncoding = this.getTransferEncoding();\n        let contentStream;\n        let localStream;\n\n        // protect actual callback against multiple triggering\n        let returned = false;\n        let callback = err => {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            done(err);\n        };\n\n        // for multipart nodes, push child nodes\n        // for content nodes end the stream\n        let finalize = () => {\n            let childId = 0;\n            let processChildNode = () => {\n                if (childId >= this.childNodes.length) {\n                    outputStream.write('\\r\\n--' + this.boundary + '--\\r\\n');\n                    return callback();\n                }\n                let child = this.childNodes[childId++];\n                outputStream.write((childId > 1 ? '\\r\\n' : '') + '--' + this.boundary + '\\r\\n');\n                child.stream(outputStream, options, err => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    setImmediate(processChildNode);\n                });\n            };\n\n            if (this.multipart) {\n                setImmediate(processChildNode);\n            } else {\n                return callback();\n            }\n        };\n\n        // pushes node content\n        let sendContent = () => {\n            if (this.content) {\n                if (Object.prototype.toString.call(this.content) === '[object Error]') {\n                    // content is already errored\n                    return callback(this.content);\n                }\n\n                if (typeof this.content.pipe === 'function') {\n                    this.content.removeListener('error', this._contentErrorHandler);\n                    this._contentErrorHandler = err => callback(err);\n                    this.content.once('error', this._contentErrorHandler);\n                }\n\n                let createStream = () => {\n                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {\n                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);\n\n                        contentStream.pipe(outputStream, {\n                            end: false\n                        });\n                        contentStream.once('end', finalize);\n                        contentStream.once('error', err => callback(err));\n\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(contentStream);\n                    } else {\n                        // anything that is not QP or Base54 passes as-is\n                        localStream = this._getStream(this.content);\n                        localStream.pipe(outputStream, {\n                            end: false\n                        });\n                        localStream.once('end', finalize);\n                    }\n\n                    localStream.once('error', err => callback(err));\n                };\n\n                if (this.content._resolve) {\n                    let chunks = [];\n                    let chunklen = 0;\n                    let returned = false;\n                    let sourceStream = this._getStream(this.content);\n                    sourceStream.on('error', err => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        callback(err);\n                    });\n                    sourceStream.on('readable', () => {\n                        let chunk;\n                        while ((chunk = sourceStream.read()) !== null) {\n                            chunks.push(chunk);\n                            chunklen += chunk.length;\n                        }\n                    });\n                    sourceStream.on('end', () => {\n                        if (returned) {\n                            return;\n                        }\n                        returned = true;\n                        this.content._resolve = false;\n                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);\n                        setImmediate(createStream);\n                    });\n                } else {\n                    setImmediate(createStream);\n                }\n                return;\n            } else {\n                return setImmediate(finalize);\n            }\n        };\n\n        if (this._raw) {\n            setImmediate(() => {\n                if (Object.prototype.toString.call(this._raw) === '[object Error]') {\n                    // content is already errored\n                    return callback(this._raw);\n                }\n\n                // remove default error handler (if set)\n                if (typeof this._raw.pipe === 'function') {\n                    this._raw.removeListener('error', this._contentErrorHandler);\n                }\n\n                let raw = this._getStream(this._raw);\n                raw.pipe(outputStream, {\n                    end: false\n                });\n                raw.on('error', err => outputStream.emit('error', err));\n                raw.on('end', finalize);\n            });\n        } else {\n            outputStream.write(this.buildHeaders() + '\\r\\n\\r\\n');\n            setImmediate(sendContent);\n        }\n    }\n\n    /**\n     * Sets envelope to be used instead of the generated one\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    setEnvelope(envelope) {\n        let list;\n\n        this._envelope = {\n            from: false,\n            to: []\n        };\n\n        if (envelope.from) {\n            list = [];\n            this._convertAddresses(this._parseAddresses(envelope.from), list);\n            list = list.filter(address => address && address.address);\n            if (list.length && list[0]) {\n                this._envelope.from = list[0].address;\n            }\n        }\n        ['to', 'cc', 'bcc'].forEach(key => {\n            if (envelope[key]) {\n                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);\n            }\n        });\n\n        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);\n\n        let standardFields = ['to', 'cc', 'bcc', 'from'];\n        Object.keys(envelope).forEach(key => {\n            if (!standardFields.includes(key)) {\n                this._envelope[key] = envelope[key];\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Generates and returns an object with parsed address fields\n     *\n     * @return {Object} Address object\n     */\n    getAddresses() {\n        let addresses = {};\n\n        this._headers.forEach(header => {\n            let key = header.key.toLowerCase();\n            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {\n                if (!Array.isArray(addresses[key])) {\n                    addresses[key] = [];\n                }\n\n                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);\n            }\n        });\n\n        return addresses;\n    }\n\n    /**\n     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses\n     *\n     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}\n     */\n    getEnvelope() {\n        if (this._envelope) {\n            return this._envelope;\n        }\n\n        let envelope = {\n            from: false,\n            to: []\n        };\n        this._headers.forEach(header => {\n            let list = [];\n            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {\n                this._convertAddresses(this._parseAddresses(header.value), list);\n                if (list.length && list[0]) {\n                    envelope.from = list[0].address;\n                }\n            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {\n                this._convertAddresses(this._parseAddresses(header.value), envelope.to);\n            }\n        });\n\n        envelope.to = envelope.to.map(to => to.address);\n\n        return envelope;\n    }\n\n    /**\n     * Returns Message-Id value. If it does not exist, then creates one\n     *\n     * @return {String} Message-Id value\n     */\n    messageId() {\n        let messageId = this.getHeader('Message-ID');\n        // You really should define your own Message-Id field!\n        if (!messageId) {\n            messageId = this._generateMessageId();\n            this.setHeader('Message-ID', messageId);\n        }\n        return messageId;\n    }\n\n    /**\n     * Sets pregenerated content that will be used as the output of this node\n     *\n     * @param {String|Buffer|Stream} Raw MIME contents\n     */\n    setRaw(raw) {\n        this._raw = raw;\n\n        if (this._raw && typeof this._raw.pipe === 'function') {\n            // pre-stream handler. might be triggered if a stream is set as content\n            // and 'error' fires before anything is done with this stream\n            this._contentErrorHandler = err => {\n                this._raw.removeListener('error', this._contentErrorHandler);\n                this._raw = err;\n            };\n            this._raw.once('error', this._contentErrorHandler);\n        }\n\n        return this;\n    }\n\n    /////// PRIVATE METHODS\n\n    /**\n     * Detects and returns handle to a stream related with the content.\n     *\n     * @param {Mixed} content Node content\n     * @returns {Object} Stream object\n     */\n    _getStream(content) {\n        let contentStream;\n\n        if (content._resolvedValue) {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content._resolvedValue));\n            return contentStream;\n        } else if (typeof content.pipe === 'function') {\n            // assume as stream\n            return content;\n        } else if (content && typeof content.path === 'string' && !content.href) {\n            if (this.disableFileAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));\n                return contentStream;\n            }\n            // read file\n            return fs.createReadStream(content.path);\n        } else if (content && typeof content.href === 'string') {\n            if (this.disableUrlAccess) {\n                contentStream = new PassThrough();\n                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));\n                return contentStream;\n            }\n            // fetch URL\n            return nmfetch(content.href, { headers: content.httpHeaders });\n        } else {\n            // pass string or buffer content as a stream\n            contentStream = new PassThrough();\n            setImmediate(() => contentStream.end(content || ''));\n            return contentStream;\n        }\n    }\n\n    /**\n     * Parses addresses. Takes in a single address or an array or an\n     * array of address arrays (eg. To: [[first group], [second group],...])\n     *\n     * @param {Mixed} addresses Addresses to be parsed\n     * @return {Array} An array of address objects\n     */\n    _parseAddresses(addresses) {\n        return [].concat.apply(\n            [],\n            [].concat(addresses).map(address => {\n                // eslint-disable-line prefer-spread\n                if (address && address.address) {\n                    address.address = this._normalizeAddress(address.address);\n                    address.name = address.name || '';\n                    return [address];\n                }\n                return addressparser(address);\n            })\n        );\n    }\n\n    /**\n     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-\n     *\n     * @param {String} key Key to be normalized\n     * @return {String} key in Camel-Case form\n     */\n    _normalizeHeaderKey(key) {\n        key = (key || '')\n            .toString()\n            // no newlines in keys\n            .replace(/\\r?\\n|\\r/g, ' ')\n            .trim()\n            .toLowerCase()\n            // use uppercase words, except MIME\n            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())\n            // special case\n            .replace(/^Content-Features$/i, 'Content-features');\n\n        return key;\n    }\n\n    /**\n     * Checks if the content type is multipart and defines boundary if needed.\n     * Doesn't return anything, modifies object argument instead.\n     *\n     * @param {Object} structured Parsed header value for 'Content-Type' key\n     */\n    _handleContentType(structured) {\n        this.contentType = structured.value.trim().toLowerCase();\n\n        this.multipart = /^multipart\\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;\n\n        if (this.multipart) {\n            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();\n        } else {\n            this.boundary = false;\n        }\n    }\n\n    /**\n     * Generates a multipart boundary value\n     *\n     * @return {String} boundary value\n     */\n    _generateBoundary() {\n        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;\n    }\n\n    /**\n     * Encodes a header value for use in the generated rfc2822 email.\n     *\n     * @param {String} key Header key\n     * @param {String} value Header value\n     */\n    _encodeHeaderValue(key, value) {\n        key = this._normalizeHeaderKey(key);\n\n        switch (key) {\n            // Structured headers\n            case 'From':\n            case 'Sender':\n            case 'To':\n            case 'Cc':\n            case 'Bcc':\n            case 'Reply-To':\n                return this._convertAddresses(this._parseAddresses(value));\n\n            // values enclosed in <>\n            case 'Message-ID':\n            case 'In-Reply-To':\n            case 'Content-Id':\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n                if (value.charAt(0) !== '<') {\n                    value = '<' + value;\n                }\n\n                if (value.charAt(value.length - 1) !== '>') {\n                    value = value + '>';\n                }\n                return value;\n\n            // space separated list of values enclosed in <>\n            case 'References':\n                value = [].concat\n                    .apply(\n                        [],\n                        [].concat(value || '').map(elm => {\n                            // eslint-disable-line prefer-spread\n                            elm = (elm || '')\n                                .toString()\n                                .replace(/\\r?\\n|\\r/g, ' ')\n                                .trim();\n                            return elm.replace(/<[^>]*>/g, str => str.replace(/\\s/g, '')).split(/\\s+/);\n                        })\n                    )\n                    .map(elm => {\n                        if (elm.charAt(0) !== '<') {\n                            elm = '<' + elm;\n                        }\n                        if (elm.charAt(elm.length - 1) !== '>') {\n                            elm = elm + '>';\n                        }\n                        return elm;\n                    });\n\n                return value.join(' ').trim();\n\n            case 'Date':\n                if (Object.prototype.toString.call(value) === '[object Date]') {\n                    return value.toUTCString().replace(/GMT/, '+0000');\n                }\n\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                return this._encodeWords(value);\n\n            case 'Content-Type':\n            case 'Content-Disposition':\n                // if it includes a filename then it is already encoded\n                return (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n\n            default:\n                value = (value || '').toString().replace(/\\r?\\n|\\r/g, ' ');\n                // encodeWords only encodes if needed, otherwise the original string is returned\n                return this._encodeWords(value);\n        }\n    }\n\n    /**\n     * Rebuilds address object using punycode and other adjustments\n     *\n     * @param {Array} addresses An array of address objects\n     * @param {Array} [uniqueList] An array to be populated with addresses\n     * @return {String} address string\n     */\n    _convertAddresses(addresses, uniqueList) {\n        let values = [];\n\n        uniqueList = uniqueList || [];\n\n        [].concat(addresses || []).forEach(address => {\n            if (address.address) {\n                address.address = this._normalizeAddress(address.address);\n\n                if (!address.name) {\n                    values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);\n                } else if (address.name) {\n                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);\n                }\n\n                if (address.address) {\n                    if (!uniqueList.filter(a => a.address === address.address).length) {\n                        uniqueList.push(address);\n                    }\n                }\n            } else if (address.group) {\n                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();\n                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);\n            }\n        });\n\n        return values.join(', ');\n    }\n\n    /**\n     * Normalizes an email address\n     *\n     * @param {Array} address An array of address objects\n     * @return {String} address string\n     */\n    _normalizeAddress(address) {\n        address = (address || '')\n            .toString()\n            .replace(/[\\x00-\\x1F<>]+/g, ' ') // remove unallowed characters\n            .trim();\n\n        let lastAt = address.lastIndexOf('@');\n        if (lastAt < 0) {\n            // Bare username\n            return address;\n        }\n\n        let user = address.substr(0, lastAt);\n        let domain = address.substr(lastAt + 1);\n\n        // Usernames are not touched and are kept as is even if these include unicode\n        // Domains are punycoded by default\n        // 'jÃµgeva.ee' will be converted to 'xn--jgeva-dua.ee'\n        // non-unicode domains are left as is\n\n        let encodedDomain;\n\n        try {\n            encodedDomain = punycode.toASCII(domain.toLowerCase());\n        } catch (err) {\n            // keep as is?\n        }\n\n        if (user.indexOf(' ') >= 0) {\n            if (user.charAt(0) !== '\"') {\n                user = '\"' + user;\n            }\n            if (user.substr(-1) !== '\"') {\n                user = user + '\"';\n            }\n        }\n\n        return `${user}@${encodedDomain}`;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeAddressName(name) {\n        if (!/^[\\w ']*$/.test(name)) {\n            if (/^[\\x20-\\x7e]*$/.test(name)) {\n                return '\"' + name.replace(/([\\\\\"])/g, '\\\\$1') + '\"';\n            } else {\n                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * If needed, mime encodes the name part\n     *\n     * @param {String} name Name part of an address\n     * @returns {String} Mime word encoded string if needed\n     */\n    _encodeWords(value) {\n        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,\n        // by default only words that include non-ascii should be converted into encoded words\n        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace\n        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);\n    }\n\n    /**\n     * Detects best mime encoding for a text value\n     *\n     * @param {String} value Value to check for\n     * @return {String} either 'Q' or 'B'\n     */\n    _getTextEncoding(value) {\n        value = (value || '').toString();\n\n        let encoding = this.textEncoding;\n        let latinLen;\n        let nonLatinLen;\n\n        if (!encoding) {\n            // count latin alphabet symbols and 8-bit range symbols + control symbols\n            // if there are more latin characters, then use quoted-printable\n            // encoding, otherwise use base64\n            nonLatinLen = (value.match(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\u0080-\\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex\n            latinLen = (value.match(/[a-z]/gi) || []).length;\n            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B\n            encoding = nonLatinLen < latinLen ? 'Q' : 'B';\n        }\n        return encoding;\n    }\n\n    /**\n     * Generates a message id\n     *\n     * @return {String} Random Message-ID value\n     */\n    _generateMessageId() {\n        return (\n            '<' +\n            [2, 2, 2, 6].reduce(\n                // crux to generate UUID-like random strings\n                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),\n                crypto.randomBytes(4).toString('hex')\n            ) +\n            '@' +\n            // try to use the domain of the FROM address or fallback to server hostname\n            (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() +\n            '>'\n        );\n    }\n}\n\nmodule.exports = MimeNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}