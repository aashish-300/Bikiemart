{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nvar MessageParser = /*#__PURE__*/function (_Transform) {\n  _inherits(MessageParser, _Transform);\n  var _super = _createSuper(MessageParser);\n  function MessageParser(options) {\n    var _this;\n    _classCallCheck(this, MessageParser);\n    _this = _super.call(this, options);\n    _this.lastBytes = Buffer.alloc(4);\n    _this.headersParsed = false;\n    _this.headerBytes = 0;\n    _this.headerChunks = [];\n    _this.rawHeaders = false;\n    _this.bodySize = 0;\n    return _this;\n  }\n\n  /**\n   * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n   *\n   * @param {Buffer} data Next data chunk from the stream\n   */\n  _createClass(MessageParser, [{\n    key: \"updateLastBytes\",\n    value: function updateLastBytes(data) {\n      var lblen = this.lastBytes.length;\n      var nblen = Math.min(data.length, lblen);\n\n      // shift existing bytes\n      for (var i = 0, len = lblen - nblen; i < len; i++) {\n        this.lastBytes[i] = this.lastBytes[i + nblen];\n      }\n\n      // add new bytes\n      for (var _i = 1; _i <= nblen; _i++) {\n        this.lastBytes[lblen - _i] = data[data.length - _i];\n      }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n  }, {\n    key: \"checkHeaders\",\n    value: function checkHeaders(data) {\n      var _this2 = this;\n      if (this.headersParsed) {\n        return true;\n      }\n      var lblen = this.lastBytes.length;\n      var headerPos = 0;\n      this.curLinePos = 0;\n      for (var i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n        var chr = void 0;\n        if (i < lblen) {\n          chr = this.lastBytes[i];\n        } else {\n          chr = data[i - lblen];\n        }\n        if (chr === 0x0a && i) {\n          var pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n          var pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;\n          if (pr1 === 0x0a) {\n            this.headersParsed = true;\n            headerPos = i - lblen + 1;\n            this.headerBytes += headerPos;\n            break;\n          } else if (pr1 === 0x0d && pr2 === 0x0a) {\n            this.headersParsed = true;\n            headerPos = i - lblen + 1;\n            this.headerBytes += headerPos;\n            break;\n          }\n        }\n      }\n      if (this.headersParsed) {\n        this.headerChunks.push(data.slice(0, headerPos));\n        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n        this.headerChunks = null;\n        this.emit('headers', this.parseHeaders());\n        if (data.length - 1 > headerPos) {\n          var chunk = data.slice(headerPos);\n          this.bodySize += chunk.length;\n          // this would be the first chunk of data sent downstream\n          setImmediate(function () {\n            return _this2.push(chunk);\n          });\n        }\n        return false;\n      } else {\n        this.headerBytes += data.length;\n        this.headerChunks.push(data);\n      }\n\n      // store last 4 bytes to catch header break\n      this.updateLastBytes(data);\n      return false;\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (!chunk || !chunk.length) {\n        return callback();\n      }\n      if (typeof chunk === 'string') {\n        chunk = Buffer.from(chunk, encoding);\n      }\n      var headersFound;\n      try {\n        headersFound = this.checkHeaders(chunk);\n      } catch (E) {\n        return callback(E);\n      }\n      if (headersFound) {\n        this.bodySize += chunk.length;\n        this.push(chunk);\n      }\n      setImmediate(callback);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.headerChunks) {\n        var chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n        this.bodySize += chunk.length;\n        this.push(chunk);\n        this.headerChunks = null;\n      }\n      callback();\n    }\n  }, {\n    key: \"parseHeaders\",\n    value: function parseHeaders() {\n      var lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n      for (var i = lines.length - 1; i > 0; i--) {\n        if (/^\\s/.test(lines[i])) {\n          lines[i - 1] += '\\n' + lines[i];\n          lines.splice(i, 1);\n        }\n      }\n      return lines.filter(function (line) {\n        return line.trim();\n      }).map(function (line) {\n        return {\n          key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n          line: line\n        };\n      });\n    }\n  }]);\n  return MessageParser;\n}(Transform);\nmodule.exports = MessageParser;","map":{"version":3,"names":["Transform","require","MessageParser","options","lastBytes","Buffer","alloc","headersParsed","headerBytes","headerChunks","rawHeaders","bodySize","data","lblen","length","nblen","Math","min","i","len","headerPos","curLinePos","chr","pr1","pr2","push","slice","concat","emit","parseHeaders","chunk","setImmediate","updateLastBytes","encoding","callback","from","headersFound","checkHeaders","E","lines","toString","split","test","splice","filter","line","trim","map","key","substr","indexOf","toLowerCase","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/dkim/message-parser.js"],"sourcesContent":["'use strict';\n\nconst Transform = require('stream').Transform;\n\n/**\n * MessageParser instance is a transform stream that separates message headers\n * from the rest of the body. Headers are emitted with the 'headers' event. Message\n * body is passed on as the resulting stream.\n */\nclass MessageParser extends Transform {\n    constructor(options) {\n        super(options);\n        this.lastBytes = Buffer.alloc(4);\n        this.headersParsed = false;\n        this.headerBytes = 0;\n        this.headerChunks = [];\n        this.rawHeaders = false;\n        this.bodySize = 0;\n    }\n\n    /**\n     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries\n     *\n     * @param {Buffer} data Next data chunk from the stream\n     */\n    updateLastBytes(data) {\n        let lblen = this.lastBytes.length;\n        let nblen = Math.min(data.length, lblen);\n\n        // shift existing bytes\n        for (let i = 0, len = lblen - nblen; i < len; i++) {\n            this.lastBytes[i] = this.lastBytes[i + nblen];\n        }\n\n        // add new bytes\n        for (let i = 1; i <= nblen; i++) {\n            this.lastBytes[lblen - i] = data[data.length - i];\n        }\n    }\n\n    /**\n     * Finds and removes message headers from the remaining body. We want to keep\n     * headers separated until final delivery to be able to modify these\n     *\n     * @param {Buffer} data Next chunk of data\n     * @return {Boolean} Returns true if headers are already found or false otherwise\n     */\n    checkHeaders(data) {\n        if (this.headersParsed) {\n            return true;\n        }\n\n        let lblen = this.lastBytes.length;\n        let headerPos = 0;\n        this.curLinePos = 0;\n        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {\n            let chr;\n            if (i < lblen) {\n                chr = this.lastBytes[i];\n            } else {\n                chr = data[i - lblen];\n            }\n            if (chr === 0x0a && i) {\n                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];\n                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;\n                if (pr1 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                } else if (pr1 === 0x0d && pr2 === 0x0a) {\n                    this.headersParsed = true;\n                    headerPos = i - lblen + 1;\n                    this.headerBytes += headerPos;\n                    break;\n                }\n            }\n        }\n\n        if (this.headersParsed) {\n            this.headerChunks.push(data.slice(0, headerPos));\n            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.headerChunks = null;\n            this.emit('headers', this.parseHeaders());\n            if (data.length - 1 > headerPos) {\n                let chunk = data.slice(headerPos);\n                this.bodySize += chunk.length;\n                // this would be the first chunk of data sent downstream\n                setImmediate(() => this.push(chunk));\n            }\n            return false;\n        } else {\n            this.headerBytes += data.length;\n            this.headerChunks.push(data);\n        }\n\n        // store last 4 bytes to catch header break\n        this.updateLastBytes(data);\n\n        return false;\n    }\n\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n\n        let headersFound;\n\n        try {\n            headersFound = this.checkHeaders(chunk);\n        } catch (E) {\n            return callback(E);\n        }\n\n        if (headersFound) {\n            this.bodySize += chunk.length;\n            this.push(chunk);\n        }\n\n        setImmediate(callback);\n    }\n\n    _flush(callback) {\n        if (this.headerChunks) {\n            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);\n            this.bodySize += chunk.length;\n            this.push(chunk);\n            this.headerChunks = null;\n        }\n        callback();\n    }\n\n    parseHeaders() {\n        let lines = (this.rawHeaders || '').toString().split(/\\r?\\n/);\n        for (let i = lines.length - 1; i > 0; i--) {\n            if (/^\\s/.test(lines[i])) {\n                lines[i - 1] += '\\n' + lines[i];\n                lines.splice(i, 1);\n            }\n        }\n        return lines\n            .filter(line => line.trim())\n            .map(line => ({\n                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),\n                line\n            }));\n    }\n}\n\nmodule.exports = MessageParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}