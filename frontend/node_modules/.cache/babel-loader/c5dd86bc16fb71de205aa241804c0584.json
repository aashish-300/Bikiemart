{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar EventEmitter = require('events');\nvar PoolResource = require('./pool-resource');\nvar SMTPConnection = require('../smtp-connection');\nvar wellKnown = require('../well-known');\nvar shared = require('../shared');\nvar packageData = require('../../package.json');\n\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\nvar SMTPPool = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPPool, _EventEmitter);\n  var _super = _createSuper(SMTPPool);\n  function SMTPPool(options) {\n    var _this;\n    _classCallCheck(this, SMTPPool);\n    _this = _super.call(this);\n    options = options || {};\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n    var urlData;\n    var service = options.service;\n    if (typeof options.getSocket === 'function') {\n      _this.getSocket = options.getSocket;\n    }\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n    _this.options = shared.assign(false,\n    // create new object\n    options,\n    // regular options\n    urlData,\n    // url options\n    service && wellKnown(service) // wellknown options\n    );\n\n    _this.options.maxConnections = _this.options.maxConnections || 5;\n    _this.options.maxMessages = _this.options.maxMessages || 100;\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-pool'\n    });\n\n    // temporary object\n    var connection = new SMTPConnection(_this.options);\n    _this.name = 'SMTP (pool)';\n    _this.version = packageData.version + '[client:' + connection.version + ']';\n    _this._rateLimit = {\n      counter: 0,\n      timeout: null,\n      waiting: [],\n      checkpoint: false,\n      delta: Number(_this.options.rateDelta) || 1000,\n      limit: Number(_this.options.rateLimit) || 0\n    };\n    _this._closed = false;\n    _this._queue = [];\n    _this._connections = [];\n    _this._connectionCounter = 0;\n    _this.idling = true;\n    setImmediate(function () {\n      if (_this.idling) {\n        _this.emit('idle');\n      }\n    });\n    return _this;\n  }\n\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n  _createClass(SMTPPool, [{\n    key: \"getSocket\",\n    value: function getSocket(options, callback) {\n      // return immediatelly\n      return setImmediate(function () {\n        return callback(null, false);\n      });\n    }\n\n    /**\n     * Queues an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n  }, {\n    key: \"send\",\n    value: function send(mail, callback) {\n      var _this2 = this;\n      if (this._closed) {\n        return false;\n      }\n      this._queue.push({\n        mail: mail,\n        requeueAttempts: 0,\n        callback: callback\n      });\n      if (this.idling && this._queue.length >= this.options.maxConnections) {\n        this.idling = false;\n      }\n      setImmediate(function () {\n        return _this2._processMessages();\n      });\n      return true;\n    }\n\n    /**\n     * Closes all connections in the pool. If there is a message being sent, the connection\n     * is closed later\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this3 = this;\n      var connection;\n      var len = this._connections.length;\n      this._closed = true;\n\n      // clear rate limit timer if it exists\n      clearTimeout(this._rateLimit.timeout);\n      if (!len && !this._queue.length) {\n        return;\n      }\n\n      // remove all available connections\n      for (var i = len - 1; i >= 0; i--) {\n        if (this._connections[i] && this._connections[i].available) {\n          connection = this._connections[i];\n          connection.close();\n          this.logger.info({\n            tnx: 'connection',\n            cid: connection.id,\n            action: 'removed'\n          }, 'Connection #%s removed', connection.id);\n        }\n      }\n      if (len && !this._connections.length) {\n        this.logger.debug({\n          tnx: 'connection'\n        }, 'All connections removed');\n      }\n      if (!this._queue.length) {\n        return;\n      }\n\n      // make sure that entire queue would be cleaned\n      var invokeCallbacks = function invokeCallbacks() {\n        if (!_this3._queue.length) {\n          _this3.logger.debug({\n            tnx: 'connection'\n          }, 'Pending queue entries cleared');\n          return;\n        }\n        var entry = _this3._queue.shift();\n        if (entry && typeof entry.callback === 'function') {\n          try {\n            entry.callback(new Error('Connection pool was closed'));\n          } catch (E) {\n            _this3.logger.error({\n              err: E,\n              tnx: 'callback',\n              cid: connection.id\n            }, 'Callback error for #%s: %s', connection.id, E.message);\n          }\n        }\n        setImmediate(invokeCallbacks);\n      };\n      setImmediate(invokeCallbacks);\n    }\n\n    /**\n     * Check the queue and available connections. If there is a message to be sent and there is\n     * an available connection, then use this connection to send the mail\n     */\n  }, {\n    key: \"_processMessages\",\n    value: function _processMessages() {\n      var _this4 = this;\n      var connection;\n      var i, len;\n\n      // do nothing if already closed\n      if (this._closed) {\n        return;\n      }\n\n      // do nothing if queue is empty\n      if (!this._queue.length) {\n        if (!this.idling) {\n          // no pending jobs\n          this.idling = true;\n          this.emit('idle');\n        }\n        return;\n      }\n\n      // find first available connection\n      for (i = 0, len = this._connections.length; i < len; i++) {\n        if (this._connections[i].available) {\n          connection = this._connections[i];\n          break;\n        }\n      }\n      if (!connection && this._connections.length < this.options.maxConnections) {\n        connection = this._createConnection();\n      }\n      if (!connection) {\n        // no more free connection slots available\n        this.idling = false;\n        return;\n      }\n\n      // check if there is free space in the processing queue\n      if (!this.idling && this._queue.length < this.options.maxConnections) {\n        this.idling = true;\n        this.emit('idle');\n      }\n      var entry = connection.queueEntry = this._queue.shift();\n      entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n      connection.available = false;\n      this.logger.debug({\n        tnx: 'pool',\n        cid: connection.id,\n        messageId: entry.messageId,\n        action: 'assign'\n      }, 'Assigned message <%s> to #%s (%s)', entry.messageId, connection.id, connection.messages + 1);\n      if (this._rateLimit.limit) {\n        this._rateLimit.counter++;\n        if (!this._rateLimit.checkpoint) {\n          this._rateLimit.checkpoint = Date.now();\n        }\n      }\n      connection.send(entry.mail, function (err, info) {\n        // only process callback if current handler is not changed\n        if (entry === connection.queueEntry) {\n          try {\n            entry.callback(err, info);\n          } catch (E) {\n            _this4.logger.error({\n              err: E,\n              tnx: 'callback',\n              cid: connection.id\n            }, 'Callback error for #%s: %s', connection.id, E.message);\n          }\n          connection.queueEntry = false;\n        }\n      });\n    }\n\n    /**\n     * Creates a new pool resource\n     */\n  }, {\n    key: \"_createConnection\",\n    value: function _createConnection() {\n      var _this5 = this;\n      var connection = new PoolResource(this);\n      connection.id = ++this._connectionCounter;\n      this.logger.info({\n        tnx: 'pool',\n        cid: connection.id,\n        action: 'conection'\n      }, 'Created new pool resource #%s', connection.id);\n\n      // resource comes available\n      connection.on('available', function () {\n        _this5.logger.debug({\n          tnx: 'connection',\n          cid: connection.id,\n          action: 'available'\n        }, 'Connection #%s became available', connection.id);\n        if (_this5._closed) {\n          // if already closed run close() that will remove this connections from connections list\n          _this5.close();\n        } else {\n          // check if there's anything else to send\n          _this5._processMessages();\n        }\n      });\n\n      // resource is terminated with an error\n      connection.once('error', function (err) {\n        if (err.code !== 'EMAXLIMIT') {\n          _this5.logger.error({\n            err: err,\n            tnx: 'pool',\n            cid: connection.id\n          }, 'Pool Error for #%s: %s', connection.id, err.message);\n        } else {\n          _this5.logger.debug({\n            tnx: 'pool',\n            cid: connection.id,\n            action: 'maxlimit'\n          }, 'Max messages limit exchausted for #%s', connection.id);\n        }\n        if (connection.queueEntry) {\n          try {\n            connection.queueEntry.callback(err);\n          } catch (E) {\n            _this5.logger.error({\n              err: E,\n              tnx: 'callback',\n              cid: connection.id\n            }, 'Callback error for #%s: %s', connection.id, E.message);\n          }\n          connection.queueEntry = false;\n        }\n\n        // remove the erroneus connection from connections list\n        _this5._removeConnection(connection);\n        _this5._continueProcessing();\n      });\n      connection.once('close', function () {\n        _this5.logger.info({\n          tnx: 'connection',\n          cid: connection.id,\n          action: 'closed'\n        }, 'Connection #%s was closed', connection.id);\n        _this5._removeConnection(connection);\n        if (connection.queueEntry) {\n          // If the connection closed when sending, add the message to the queue again\n          // if max number of requeues is not reached yet\n          // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n          // in the next event loop\n          setTimeout(function () {\n            if (connection.queueEntry) {\n              if (_this5._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n                _this5._requeueEntryOnConnectionClose(connection);\n              } else {\n                _this5._failDeliveryOnConnectionClose(connection);\n              }\n            }\n            _this5._continueProcessing();\n          }, 50);\n        } else {\n          _this5._continueProcessing();\n        }\n      });\n      this._connections.push(connection);\n      return connection;\n    }\n  }, {\n    key: \"_shouldRequeuOnConnectionClose\",\n    value: function _shouldRequeuOnConnectionClose(queueEntry) {\n      if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n        return true;\n      }\n      return queueEntry.requeueAttempts < this.options.maxRequeues;\n    }\n  }, {\n    key: \"_failDeliveryOnConnectionClose\",\n    value: function _failDeliveryOnConnectionClose(connection) {\n      if (connection.queueEntry && connection.queueEntry.callback) {\n        try {\n          connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n        } catch (E) {\n          this.logger.error({\n            err: E,\n            tnx: 'callback',\n            messageId: connection.queueEntry.messageId,\n            cid: connection.id\n          }, 'Callback error for #%s: %s', connection.id, E.message);\n        }\n        connection.queueEntry = false;\n      }\n    }\n  }, {\n    key: \"_requeueEntryOnConnectionClose\",\n    value: function _requeueEntryOnConnectionClose(connection) {\n      connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n      this.logger.debug({\n        tnx: 'pool',\n        cid: connection.id,\n        messageId: connection.queueEntry.messageId,\n        action: 'requeue'\n      }, 'Re-queued message <%s> for #%s. Attempt: #%s', connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);\n      this._queue.unshift(connection.queueEntry);\n      connection.queueEntry = false;\n    }\n\n    /**\n     * Continue to process message if the pool hasn't closed\n     */\n  }, {\n    key: \"_continueProcessing\",\n    value: function _continueProcessing() {\n      var _this6 = this;\n      if (this._closed) {\n        this.close();\n      } else {\n        setTimeout(function () {\n          return _this6._processMessages();\n        }, 100);\n      }\n    }\n\n    /**\n     * Remove resource from pool\n     *\n     * @param {Object} connection The PoolResource to remove\n     */\n  }, {\n    key: \"_removeConnection\",\n    value: function _removeConnection(connection) {\n      var index = this._connections.indexOf(connection);\n      if (index !== -1) {\n        this._connections.splice(index, 1);\n      }\n    }\n\n    /**\n     * Checks if connections have hit current rate limit and if so, queues the availability callback\n     *\n     * @param {Function} callback Callback function to run once rate limiter has been cleared\n     */\n  }, {\n    key: \"_checkRateLimit\",\n    value: function _checkRateLimit(callback) {\n      var _this7 = this;\n      if (!this._rateLimit.limit) {\n        return callback();\n      }\n      var now = Date.now();\n      if (this._rateLimit.counter < this._rateLimit.limit) {\n        return callback();\n      }\n      this._rateLimit.waiting.push(callback);\n      if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n        return this._clearRateLimit();\n      } else if (!this._rateLimit.timeout) {\n        this._rateLimit.timeout = setTimeout(function () {\n          return _this7._clearRateLimit();\n        }, this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n        this._rateLimit.checkpoint = now;\n      }\n    }\n\n    /**\n     * Clears current rate limit limitation and runs paused callback\n     */\n  }, {\n    key: \"_clearRateLimit\",\n    value: function _clearRateLimit() {\n      clearTimeout(this._rateLimit.timeout);\n      this._rateLimit.timeout = null;\n      this._rateLimit.counter = 0;\n      this._rateLimit.checkpoint = false;\n\n      // resume all paused connections\n      while (this._rateLimit.waiting.length) {\n        var cb = this._rateLimit.waiting.shift();\n        setImmediate(cb);\n      }\n    }\n\n    /**\n     * Returns true if there are free slots in the queue\n     */\n  }, {\n    key: \"isIdle\",\n    value: function isIdle() {\n      return this.idling;\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n  }, {\n    key: \"verify\",\n    value: function verify(callback) {\n      var _this8 = this;\n      var promise;\n      if (!callback) {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n      var auth = new PoolResource(this).auth;\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n        var options = _this8.options;\n        if (socketOptions && socketOptions.connection) {\n          _this8.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n        var connection = new SMTPConnection(options);\n        var returned = false;\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          return callback(new Error('Connection closed'));\n        });\n        var finalize = function finalize() {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          connection.quit();\n          return callback(null, true);\n        };\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n          if (auth && (connection.allowsAuth || options.forceAuth)) {\n            connection.login(auth, function (err) {\n              if (returned) {\n                return;\n              }\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n              finalize();\n            });\n          } else if (!auth && connection.allowsAuth && options.forceAuth) {\n            var _err = new Error('Authentication info was not provided');\n            _err.code = 'NoAuth';\n            returned = true;\n            connection.close();\n            return callback(_err);\n          } else {\n            finalize();\n          }\n        });\n      });\n      return promise;\n    }\n  }]);\n  return SMTPPool;\n}(EventEmitter); // expose to the world\nmodule.exports = SMTPPool;","map":{"version":3,"names":["EventEmitter","require","PoolResource","SMTPConnection","wellKnown","shared","packageData","SMTPPool","options","url","urlData","service","getSocket","parseConnectionUrl","assign","maxConnections","maxMessages","logger","getLogger","component","connection","name","version","_rateLimit","counter","timeout","waiting","checkpoint","delta","Number","rateDelta","limit","rateLimit","_closed","_queue","_connections","_connectionCounter","idling","setImmediate","emit","callback","mail","push","requeueAttempts","length","_processMessages","len","clearTimeout","i","available","close","info","tnx","cid","id","action","debug","invokeCallbacks","entry","shift","Error","E","error","err","message","_createConnection","queueEntry","messageId","getHeader","replace","messages","Date","now","send","on","once","code","_removeConnection","_continueProcessing","setTimeout","_shouldRequeuOnConnectionClose","_requeueEntryOnConnectionClose","_failDeliveryOnConnectionClose","maxRequeues","undefined","unshift","index","indexOf","splice","_clearRateLimit","cb","promise","Promise","resolve","reject","callbackPromise","auth","socketOptions","remoteAddress","remotePort","destHost","host","destPort","port","Object","keys","forEach","key","returned","finalize","quit","connect","allowsAuth","forceAuth","login","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/smtp-pool/index.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst PoolResource = require('./pool-resource');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP pool transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options SMTP Connection options\n */\nclass SMTPPool extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.options.maxConnections = this.options.maxConnections || 5;\n        this.options.maxMessages = this.options.maxMessages || 100;\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-pool'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP (pool)';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        this._rateLimit = {\n            counter: 0,\n            timeout: null,\n            waiting: [],\n            checkpoint: false,\n            delta: Number(this.options.rateDelta) || 1000,\n            limit: Number(this.options.rateLimit) || 0\n        };\n        this._closed = false;\n        this._queue = [];\n        this._connections = [];\n        this._connectionCounter = 0;\n\n        this.idling = true;\n\n        setImmediate(() => {\n            if (this.idling) {\n                this.emit('idle');\n            }\n        });\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    /**\n     * Queues an e-mail to be sent using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        if (this._closed) {\n            return false;\n        }\n\n        this._queue.push({\n            mail,\n            requeueAttempts: 0,\n            callback\n        });\n\n        if (this.idling && this._queue.length >= this.options.maxConnections) {\n            this.idling = false;\n        }\n\n        setImmediate(() => this._processMessages());\n\n        return true;\n    }\n\n    /**\n     * Closes all connections in the pool. If there is a message being sent, the connection\n     * is closed later\n     */\n    close() {\n        let connection;\n        let len = this._connections.length;\n        this._closed = true;\n\n        // clear rate limit timer if it exists\n        clearTimeout(this._rateLimit.timeout);\n\n        if (!len && !this._queue.length) {\n            return;\n        }\n\n        // remove all available connections\n        for (let i = len - 1; i >= 0; i--) {\n            if (this._connections[i] && this._connections[i].available) {\n                connection = this._connections[i];\n                connection.close();\n                this.logger.info(\n                    {\n                        tnx: 'connection',\n                        cid: connection.id,\n                        action: 'removed'\n                    },\n                    'Connection #%s removed',\n                    connection.id\n                );\n            }\n        }\n\n        if (len && !this._connections.length) {\n            this.logger.debug(\n                {\n                    tnx: 'connection'\n                },\n                'All connections removed'\n            );\n        }\n\n        if (!this._queue.length) {\n            return;\n        }\n\n        // make sure that entire queue would be cleaned\n        let invokeCallbacks = () => {\n            if (!this._queue.length) {\n                this.logger.debug(\n                    {\n                        tnx: 'connection'\n                    },\n                    'Pending queue entries cleared'\n                );\n                return;\n            }\n            let entry = this._queue.shift();\n            if (entry && typeof entry.callback === 'function') {\n                try {\n                    entry.callback(new Error('Connection pool was closed'));\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n            }\n            setImmediate(invokeCallbacks);\n        };\n        setImmediate(invokeCallbacks);\n    }\n\n    /**\n     * Check the queue and available connections. If there is a message to be sent and there is\n     * an available connection, then use this connection to send the mail\n     */\n    _processMessages() {\n        let connection;\n        let i, len;\n\n        // do nothing if already closed\n        if (this._closed) {\n            return;\n        }\n\n        // do nothing if queue is empty\n        if (!this._queue.length) {\n            if (!this.idling) {\n                // no pending jobs\n                this.idling = true;\n                this.emit('idle');\n            }\n            return;\n        }\n\n        // find first available connection\n        for (i = 0, len = this._connections.length; i < len; i++) {\n            if (this._connections[i].available) {\n                connection = this._connections[i];\n                break;\n            }\n        }\n\n        if (!connection && this._connections.length < this.options.maxConnections) {\n            connection = this._createConnection();\n        }\n\n        if (!connection) {\n            // no more free connection slots available\n            this.idling = false;\n            return;\n        }\n\n        // check if there is free space in the processing queue\n        if (!this.idling && this._queue.length < this.options.maxConnections) {\n            this.idling = true;\n            this.emit('idle');\n        }\n\n        let entry = (connection.queueEntry = this._queue.shift());\n        entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n\n        connection.available = false;\n\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: entry.messageId,\n                action: 'assign'\n            },\n            'Assigned message <%s> to #%s (%s)',\n            entry.messageId,\n            connection.id,\n            connection.messages + 1\n        );\n\n        if (this._rateLimit.limit) {\n            this._rateLimit.counter++;\n            if (!this._rateLimit.checkpoint) {\n                this._rateLimit.checkpoint = Date.now();\n            }\n        }\n\n        connection.send(entry.mail, (err, info) => {\n            // only process callback if current handler is not changed\n            if (entry === connection.queueEntry) {\n                try {\n                    entry.callback(err, info);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n        });\n    }\n\n    /**\n     * Creates a new pool resource\n     */\n    _createConnection() {\n        let connection = new PoolResource(this);\n\n        connection.id = ++this._connectionCounter;\n\n        this.logger.info(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                action: 'conection'\n            },\n            'Created new pool resource #%s',\n            connection.id\n        );\n\n        // resource comes available\n        connection.on('available', () => {\n            this.logger.debug(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'available'\n                },\n                'Connection #%s became available',\n                connection.id\n            );\n\n            if (this._closed) {\n                // if already closed run close() that will remove this connections from connections list\n                this.close();\n            } else {\n                // check if there's anything else to send\n                this._processMessages();\n            }\n        });\n\n        // resource is terminated with an error\n        connection.once('error', err => {\n            if (err.code !== 'EMAXLIMIT') {\n                this.logger.error(\n                    {\n                        err,\n                        tnx: 'pool',\n                        cid: connection.id\n                    },\n                    'Pool Error for #%s: %s',\n                    connection.id,\n                    err.message\n                );\n            } else {\n                this.logger.debug(\n                    {\n                        tnx: 'pool',\n                        cid: connection.id,\n                        action: 'maxlimit'\n                    },\n                    'Max messages limit exchausted for #%s',\n                    connection.id\n                );\n            }\n\n            if (connection.queueEntry) {\n                try {\n                    connection.queueEntry.callback(err);\n                } catch (E) {\n                    this.logger.error(\n                        {\n                            err: E,\n                            tnx: 'callback',\n                            cid: connection.id\n                        },\n                        'Callback error for #%s: %s',\n                        connection.id,\n                        E.message\n                    );\n                }\n                connection.queueEntry = false;\n            }\n\n            // remove the erroneus connection from connections list\n            this._removeConnection(connection);\n\n            this._continueProcessing();\n        });\n\n        connection.once('close', () => {\n            this.logger.info(\n                {\n                    tnx: 'connection',\n                    cid: connection.id,\n                    action: 'closed'\n                },\n                'Connection #%s was closed',\n                connection.id\n            );\n\n            this._removeConnection(connection);\n\n            if (connection.queueEntry) {\n                // If the connection closed when sending, add the message to the queue again\n                // if max number of requeues is not reached yet\n                // Note that we must wait a bit.. because the callback of the 'error' handler might be called\n                // in the next event loop\n                setTimeout(() => {\n                    if (connection.queueEntry) {\n                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {\n                            this._requeueEntryOnConnectionClose(connection);\n                        } else {\n                            this._failDeliveryOnConnectionClose(connection);\n                        }\n                    }\n                    this._continueProcessing();\n                }, 50);\n            } else {\n                this._continueProcessing();\n            }\n        });\n\n        this._connections.push(connection);\n\n        return connection;\n    }\n\n    _shouldRequeuOnConnectionClose(queueEntry) {\n        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {\n            return true;\n        }\n\n        return queueEntry.requeueAttempts < this.options.maxRequeues;\n    }\n\n    _failDeliveryOnConnectionClose(connection) {\n        if (connection.queueEntry && connection.queueEntry.callback) {\n            try {\n                connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));\n            } catch (E) {\n                this.logger.error(\n                    {\n                        err: E,\n                        tnx: 'callback',\n                        messageId: connection.queueEntry.messageId,\n                        cid: connection.id\n                    },\n                    'Callback error for #%s: %s',\n                    connection.id,\n                    E.message\n                );\n            }\n            connection.queueEntry = false;\n        }\n    }\n\n    _requeueEntryOnConnectionClose(connection) {\n        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;\n        this.logger.debug(\n            {\n                tnx: 'pool',\n                cid: connection.id,\n                messageId: connection.queueEntry.messageId,\n                action: 'requeue'\n            },\n            'Re-queued message <%s> for #%s. Attempt: #%s',\n            connection.queueEntry.messageId,\n            connection.id,\n            connection.queueEntry.requeueAttempts\n        );\n        this._queue.unshift(connection.queueEntry);\n        connection.queueEntry = false;\n    }\n\n    /**\n     * Continue to process message if the pool hasn't closed\n     */\n    _continueProcessing() {\n        if (this._closed) {\n            this.close();\n        } else {\n            setTimeout(() => this._processMessages(), 100);\n        }\n    }\n\n    /**\n     * Remove resource from pool\n     *\n     * @param {Object} connection The PoolResource to remove\n     */\n    _removeConnection(connection) {\n        let index = this._connections.indexOf(connection);\n\n        if (index !== -1) {\n            this._connections.splice(index, 1);\n        }\n    }\n\n    /**\n     * Checks if connections have hit current rate limit and if so, queues the availability callback\n     *\n     * @param {Function} callback Callback function to run once rate limiter has been cleared\n     */\n    _checkRateLimit(callback) {\n        if (!this._rateLimit.limit) {\n            return callback();\n        }\n\n        let now = Date.now();\n\n        if (this._rateLimit.counter < this._rateLimit.limit) {\n            return callback();\n        }\n\n        this._rateLimit.waiting.push(callback);\n\n        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {\n            return this._clearRateLimit();\n        } else if (!this._rateLimit.timeout) {\n            this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));\n            this._rateLimit.checkpoint = now;\n        }\n    }\n\n    /**\n     * Clears current rate limit limitation and runs paused callback\n     */\n    _clearRateLimit() {\n        clearTimeout(this._rateLimit.timeout);\n        this._rateLimit.timeout = null;\n        this._rateLimit.counter = 0;\n        this._rateLimit.checkpoint = false;\n\n        // resume all paused connections\n        while (this._rateLimit.waiting.length) {\n            let cb = this._rateLimit.waiting.shift();\n            setImmediate(cb);\n        }\n    }\n\n    /**\n     * Returns true if there are free slots in the queue\n     */\n    isIdle() {\n        return this.idling;\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        let auth = new PoolResource(this).auth;\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else if (!auth && connection.allowsAuth && options.forceAuth) {\n                    let err = new Error('Authentication info was not provided');\n                    err.code = 'NoAuth';\n\n                    returned = true;\n                    connection.close();\n                    return callback(err);\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPPool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}