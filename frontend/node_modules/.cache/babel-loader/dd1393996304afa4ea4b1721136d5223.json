{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar packageInfo = require('../../package.json');\nvar EventEmitter = require('events').EventEmitter;\nvar net = require('net');\nvar tls = require('tls');\nvar os = require('os');\nvar crypto = require('crypto');\nvar DataStream = require('./data-stream');\nvar PassThrough = require('stream').PassThrough;\nvar shared = require('../shared');\n\n// default timeout values in ms\nvar CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nvar SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nvar GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nvar DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nvar SMTPConnection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPConnection, _EventEmitter);\n  var _super = _createSuper(SMTPConnection);\n  function SMTPConnection(options) {\n    var _this;\n    _classCallCheck(this, SMTPConnection);\n    _this = _super.call(this, options);\n    _this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    _this.stage = 'init';\n    _this.options = options || {};\n    _this.secureConnection = !!_this.options.secure;\n    _this.alreadySecured = !!_this.options.secured;\n    _this.port = Number(_this.options.port) || (_this.secureConnection ? 465 : 587);\n    _this.host = _this.options.host || 'localhost';\n    _this.allowInternalNetworkInterfaces = _this.options.allowInternalNetworkInterfaces || false;\n    if (typeof _this.options.secure === 'undefined' && _this.port === 465) {\n      // if secure option is not set but port is 465, then default to secure\n      _this.secureConnection = true;\n    }\n    _this.name = _this.options.name || _this._getHostname();\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-connection',\n      sid: _this.id\n    });\n    _this.customAuth = new Map();\n    Object.keys(_this.options.customAuth || {}).forEach(function (key) {\n      var mapKey = (key || '').toString().trim().toUpperCase();\n      if (!mapKey) {\n        return;\n      }\n      _this.customAuth.set(mapKey, _this.options.customAuth[key]);\n    });\n\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n    _this.version = packageInfo.version;\n\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n    _this.authenticated = false;\n\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n    _this.destroyed = false;\n\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n    _this.secure = !!_this.secureConnection;\n\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n    _this._remainder = '';\n\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n    _this._responseQueue = [];\n    _this.lastServerResponse = false;\n\n    /**\n     * The socket connecting to the server\n     * @publick\n     */\n    _this._socket = false;\n\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n    _this._supportedAuth = [];\n\n    /**\n     * Set to true, if EHLO response includes \"AUTH\".\n     * If false then authentication is not tried\n     */\n    _this.allowsAuth = false;\n\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n    _this._envelope = false;\n\n    /**\n     * Lists supported extensions\n     * @private\n     */\n    _this._supportedExtensions = [];\n\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n    _this._maxAllowedSize = 0;\n\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n    _this._responseActions = [];\n    _this._recipientQueue = [];\n\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n    _this._greetingTimeout = false;\n\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n    _this._connectionTimeout = false;\n\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n    _this._destroyed = false;\n\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n    _this._closing = false;\n\n    /**\n     * Callbacks for socket's listeners\n     */\n    _this._onSocketData = function (chunk) {\n      return _this._onData(chunk);\n    };\n    _this._onSocketError = function (error) {\n      return _this._onError(error, 'ESOCKET', false, 'CONN');\n    };\n    _this._onSocketClose = function () {\n      return _this._onClose();\n    };\n    _this._onSocketEnd = function () {\n      return _this._onEnd();\n    };\n    _this._onSocketTimeout = function () {\n      return _this._onTimeout();\n    };\n    return _this;\n  }\n\n  /**\n   * Creates a connection to a SMTP server and sets up connection\n   * listener\n   */\n  _createClass(SMTPConnection, [{\n    key: \"connect\",\n    value: function connect(connectCallback) {\n      var _this2 = this;\n      if (typeof connectCallback === 'function') {\n        this.once('connect', function () {\n          _this2.logger.debug({\n            tnx: 'smtp'\n          }, 'SMTP handshake finished');\n          connectCallback();\n        });\n        var isDestroyedMessage = this._isDestroyedMessage('connect');\n        if (isDestroyedMessage) {\n          return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n        }\n      }\n      var opts = {\n        port: this.port,\n        host: this.host,\n        allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n        timeout: this.options.dnsTimeout || DNS_TIMEOUT\n      };\n      if (this.options.localAddress) {\n        opts.localAddress = this.options.localAddress;\n      }\n      var setupConnectionHandlers = function setupConnectionHandlers() {\n        _this2._connectionTimeout = setTimeout(function () {\n          _this2._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n        }, _this2.options.connectionTimeout || CONNECTION_TIMEOUT);\n        _this2._socket.on('error', _this2._onSocketError);\n      };\n      if (this.options.connection) {\n        // connection is already opened\n        this._socket = this.options.connection;\n        if (this.secureConnection && !this.alreadySecured) {\n          setImmediate(function () {\n            return _this2._upgradeConnection(function (err) {\n              if (err) {\n                _this2._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                return;\n              }\n              _this2._onConnect();\n            });\n          });\n        } else {\n          setImmediate(function () {\n            return _this2._onConnect();\n          });\n        }\n        return;\n      } else if (this.options.socket) {\n        // socket object is set up but not yet connected\n        this._socket = this.options.socket;\n        return shared.resolveHostname(opts, function (err, resolved) {\n          if (err) {\n            return setImmediate(function () {\n              return _this2._onError(err, 'EDNS', false, 'CONN');\n            });\n          }\n          _this2.logger.debug({\n            tnx: 'dns',\n            source: opts.host,\n            resolved: resolved.host,\n            cached: !!resolved.cached\n          }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n          Object.keys(resolved).forEach(function (key) {\n            if (key.charAt(0) !== '_' && resolved[key]) {\n              opts[key] = resolved[key];\n            }\n          });\n          try {\n            _this2._socket.connect(_this2.port, _this2.host, function () {\n              _this2._socket.setKeepAlive(true);\n              _this2._onConnect();\n            });\n            setupConnectionHandlers();\n          } catch (E) {\n            return setImmediate(function () {\n              return _this2._onError(E, 'ECONNECTION', false, 'CONN');\n            });\n          }\n        });\n      } else if (this.secureConnection) {\n        // connect using tls\n        if (this.options.tls) {\n          Object.keys(this.options.tls).forEach(function (key) {\n            opts[key] = _this2.options.tls[key];\n          });\n        }\n        return shared.resolveHostname(opts, function (err, resolved) {\n          if (err) {\n            return setImmediate(function () {\n              return _this2._onError(err, 'EDNS', false, 'CONN');\n            });\n          }\n          _this2.logger.debug({\n            tnx: 'dns',\n            source: opts.host,\n            resolved: resolved.host,\n            cached: !!resolved.cached\n          }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n          Object.keys(resolved).forEach(function (key) {\n            if (key.charAt(0) !== '_' && resolved[key]) {\n              opts[key] = resolved[key];\n            }\n          });\n          try {\n            _this2._socket = tls.connect(opts, function () {\n              _this2._socket.setKeepAlive(true);\n              _this2._onConnect();\n            });\n            setupConnectionHandlers();\n          } catch (E) {\n            return setImmediate(function () {\n              return _this2._onError(E, 'ECONNECTION', false, 'CONN');\n            });\n          }\n        });\n      } else {\n        // connect using plaintext\n        return shared.resolveHostname(opts, function (err, resolved) {\n          if (err) {\n            return setImmediate(function () {\n              return _this2._onError(err, 'EDNS', false, 'CONN');\n            });\n          }\n          _this2.logger.debug({\n            tnx: 'dns',\n            source: opts.host,\n            resolved: resolved.host,\n            cached: !!resolved.cached\n          }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n          Object.keys(resolved).forEach(function (key) {\n            if (key.charAt(0) !== '_' && resolved[key]) {\n              opts[key] = resolved[key];\n            }\n          });\n          try {\n            _this2._socket = net.connect(opts, function () {\n              _this2._socket.setKeepAlive(true);\n              _this2._onConnect();\n            });\n            setupConnectionHandlers();\n          } catch (E) {\n            return setImmediate(function () {\n              return _this2._onError(E, 'ECONNECTION', false, 'CONN');\n            });\n          }\n        });\n      }\n    }\n\n    /**\n     * Sends QUIT\n     */\n  }, {\n    key: \"quit\",\n    value: function quit() {\n      this._sendCommand('QUIT');\n      this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      clearTimeout(this._connectionTimeout);\n      clearTimeout(this._greetingTimeout);\n      this._responseActions = [];\n\n      // allow to run this function only once\n      if (this._closing) {\n        return;\n      }\n      this._closing = true;\n      var closeMethod = 'end';\n      if (this.stage === 'init') {\n        // Close the socket immediately when connection timed out\n        closeMethod = 'destroy';\n      }\n      this.logger.debug({\n        tnx: 'smtp'\n      }, 'Closing connection to the server using \"%s\"', closeMethod);\n      var socket = this._socket && this._socket.socket || this._socket;\n      if (socket && !socket.destroyed) {\n        try {\n          this._socket[closeMethod]();\n        } catch (E) {\n          // just ignore\n        }\n      }\n      this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n  }, {\n    key: \"login\",\n    value: function login(authData, callback) {\n      var _this3 = this;\n      var isDestroyedMessage = this._isDestroyedMessage('login');\n      if (isDestroyedMessage) {\n        return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n      }\n      this._auth = authData || {};\n      // Select SASL authentication method\n      this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n      if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n        this._authMethod = 'XOAUTH2';\n      } else if (!this._authMethod || this._authMethod === 'XOAUTH2' && !this._auth.oauth2) {\n        // use first supported\n        this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n      }\n      if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n        if (this._auth.user && this._auth.pass) {\n          this._auth.credentials = {\n            user: this._auth.user,\n            pass: this._auth.pass,\n            options: this._auth.options\n          };\n        } else {\n          return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n        }\n      }\n      if (this.customAuth.has(this._authMethod)) {\n        var handler = this.customAuth.get(this._authMethod);\n        var lastResponse;\n        var returned = false;\n        var resolve = function resolve() {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          _this3.logger.info({\n            tnx: 'smtp',\n            username: _this3._auth.user,\n            action: 'authenticated',\n            method: _this3._authMethod\n          }, 'User %s authenticated', JSON.stringify(_this3._auth.user));\n          _this3.authenticated = true;\n          callback(null, true);\n        };\n        var reject = function reject(err) {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          callback(_this3._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + _this3._authMethod));\n        };\n        var handlerResponse = handler({\n          auth: this._auth,\n          method: this._authMethod,\n          extensions: [].concat(this._supportedExtensions),\n          authMethods: [].concat(this._supportedAuth),\n          maxAllowedSize: this._maxAllowedSize || false,\n          sendCommand: function sendCommand(cmd, done) {\n            var promise;\n            if (!done) {\n              promise = new Promise(function (resolve, reject) {\n                done = shared.callbackPromise(resolve, reject);\n              });\n            }\n            _this3._responseActions.push(function (str) {\n              lastResponse = str;\n              var codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n              var data = {\n                command: cmd,\n                response: str\n              };\n              if (codes) {\n                data.status = Number(codes[1]) || 0;\n                if (codes[2]) {\n                  data.code = codes[2];\n                }\n                data.text = str.substr(codes[0].length);\n              } else {\n                data.text = str;\n                data.status = 0; // just in case we need to perform numeric comparisons\n              }\n\n              done(null, data);\n            });\n            setImmediate(function () {\n              return _this3._sendCommand(cmd);\n            });\n            return promise;\n          },\n          resolve: resolve,\n          reject: reject\n        });\n        if (handlerResponse && typeof handlerResponse.catch === 'function') {\n          // a promise was returned\n          handlerResponse.then(resolve).catch(reject);\n        }\n        return;\n      }\n      switch (this._authMethod) {\n        case 'XOAUTH2':\n          this._handleXOauth2Token(false, callback);\n          return;\n        case 'LOGIN':\n          this._responseActions.push(function (str) {\n            _this3._actionAUTH_LOGIN_USER(str, callback);\n          });\n          this._sendCommand('AUTH LOGIN');\n          return;\n        case 'PLAIN':\n          this._responseActions.push(function (str) {\n            _this3._actionAUTHComplete(str, callback);\n          });\n          this._sendCommand('AUTH PLAIN ' + Buffer.from(\n          //this._auth.user+'\\u0000'+\n          \"\\0\" +\n          // skip authorization identity as it causes problems with some servers\n          this._auth.credentials.user + \"\\0\" + this._auth.credentials.pass, 'utf-8').toString('base64'),\n          // log entry without passwords\n          'AUTH PLAIN ' + Buffer.from(\n          //this._auth.user+'\\u0000'+\n          \"\\0\" +\n          // skip authorization identity as it causes problems with some servers\n          this._auth.credentials.user + \"\\0\" + '/* secret */', 'utf-8').toString('base64'));\n          return;\n        case 'CRAM-MD5':\n          this._responseActions.push(function (str) {\n            _this3._actionAUTH_CRAM_MD5(str, callback);\n          });\n          this._sendCommand('AUTH CRAM-MD5');\n          return;\n      }\n      return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n  }, {\n    key: \"send\",\n    value: function send(envelope, message, done) {\n      var _this4 = this;\n      if (!message) {\n        return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n      }\n      var isDestroyedMessage = this._isDestroyedMessage('send message');\n      if (isDestroyedMessage) {\n        return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n      }\n\n      // reject larger messages than allowed\n      if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n        return setImmediate(function () {\n          done(_this4._formatError('Message size larger than allowed ' + _this4._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n        });\n      }\n\n      // ensure that callback is only called once\n      var returned = false;\n      var callback = function callback() {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        done.apply(void 0, arguments);\n      };\n      if (typeof message.on === 'function') {\n        message.on('error', function (err) {\n          return callback(_this4._formatError(err, 'ESTREAM', false, 'API'));\n        });\n      }\n      var startTime = Date.now();\n      this._setEnvelope(envelope, function (err, info) {\n        if (err) {\n          return callback(err);\n        }\n        var envelopeTime = Date.now();\n        var stream = _this4._createSendStream(function (err, str) {\n          if (err) {\n            return callback(err);\n          }\n          info.envelopeTime = envelopeTime - startTime;\n          info.messageTime = Date.now() - envelopeTime;\n          info.messageSize = stream.outByteCount;\n          info.response = str;\n          return callback(null, info);\n        });\n        if (typeof message.pipe === 'function') {\n          message.pipe(stream);\n        } else {\n          stream.write(message);\n          stream.end();\n        }\n      });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n  }, {\n    key: \"reset\",\n    value: function reset(callback) {\n      var _this5 = this;\n      this._sendCommand('RSET');\n      this._responseActions.push(function (str) {\n        if (str.charAt(0) !== '2') {\n          return callback(_this5._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n        }\n        _this5._envelope = false;\n        return callback(null, true);\n      });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      var _this6 = this;\n      clearTimeout(this._connectionTimeout);\n      this.logger.info({\n        tnx: 'network',\n        localAddress: this._socket.localAddress,\n        localPort: this._socket.localPort,\n        remoteAddress: this._socket.remoteAddress,\n        remotePort: this._socket.remotePort\n      }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n      if (this._destroyed) {\n        // Connection was established after we already had canceled it\n        this.close();\n        return;\n      }\n      this.stage = 'connected';\n\n      // clear existing listeners for the socket\n      this._socket.removeListener('data', this._onSocketData);\n      this._socket.removeListener('timeout', this._onSocketTimeout);\n      this._socket.removeListener('close', this._onSocketClose);\n      this._socket.removeListener('end', this._onSocketEnd);\n      this._socket.on('data', this._onSocketData);\n      this._socket.once('close', this._onSocketClose);\n      this._socket.once('end', this._onSocketEnd);\n      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n      this._socket.on('timeout', this._onSocketTimeout);\n      this._greetingTimeout = setTimeout(function () {\n        // if still waiting for greeting, give up\n        if (_this6._socket && !_this6._destroyed && _this6._responseActions[0] === _this6._actionGreeting) {\n          _this6._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n        }\n      }, this.options.greetingTimeout || GREETING_TIMEOUT);\n      this._responseActions.push(this._actionGreeting);\n\n      // we have a 'data' listener set up so resume socket if it was paused\n      this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n  }, {\n    key: \"_onData\",\n    value: function _onData(chunk) {\n      if (this._destroyed || !chunk || !chunk.length) {\n        return;\n      }\n      var data = (chunk || '').toString('binary');\n      var lines = (this._remainder + data).split(/\\r?\\n/);\n      var lastline;\n      this._remainder = lines.pop();\n      for (var i = 0, len = lines.length; i < len; i++) {\n        if (this._responseQueue.length) {\n          lastline = this._responseQueue[this._responseQueue.length - 1];\n          if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n            this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n            continue;\n          }\n        }\n        this._responseQueue.push(lines[i]);\n      }\n      if (this._responseQueue.length) {\n        lastline = this._responseQueue[this._responseQueue.length - 1];\n        if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n          return;\n        }\n      }\n      this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n  }, {\n    key: \"_onError\",\n    value: function _onError(err, type, data, command) {\n      clearTimeout(this._connectionTimeout);\n      clearTimeout(this._greetingTimeout);\n      if (this._destroyed) {\n        // just ignore, already closed\n        // this might happen when a socket is canceled because of reached timeout\n        // but the socket timeout error itself receives only after\n        return;\n      }\n      err = this._formatError(err, type, data, command);\n      this.logger.error(data, err.message);\n      this.emit('error', err);\n      this.close();\n    }\n  }, {\n    key: \"_formatError\",\n    value: function _formatError(message, type, response, command) {\n      var err;\n      if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n        err = message;\n      } else {\n        err = new Error(message);\n      }\n      if (type && type !== 'Error') {\n        err.code = type;\n      }\n      if (response) {\n        err.response = response;\n        err.message += ': ' + response;\n      }\n      var responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n      if (responseCode) {\n        err.responseCode = responseCode;\n      }\n      if (command) {\n        err.command = command;\n      }\n      return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n  }, {\n    key: \"_onClose\",\n    value: function _onClose() {\n      this.logger.info({\n        tnx: 'network'\n      }, 'Connection closed');\n      if (this.upgrading && !this._destroyed) {\n        return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n      } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n        return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n      }\n      this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n  }, {\n    key: \"_onEnd\",\n    value: function _onEnd() {\n      if (this._socket && !this._socket.destroyed) {\n        this._socket.destroy();\n      }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n  }, {\n    key: \"_onTimeout\",\n    value: function _onTimeout() {\n      return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (this._destroyed) {\n        return;\n      }\n      this._destroyed = true;\n      this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n  }, {\n    key: \"_upgradeConnection\",\n    value: function _upgradeConnection(callback) {\n      var _this7 = this;\n      // do not remove all listeners or it breaks node v0.10 as there's\n      // apparently a 'finish' event set that would be cleared as well\n\n      // we can safely keep 'error', 'end', 'close' etc. events\n      this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n      this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n      var socketPlain = this._socket;\n      var opts = {\n        socket: this._socket,\n        host: this.host\n      };\n      Object.keys(this.options.tls || {}).forEach(function (key) {\n        opts[key] = _this7.options.tls[key];\n      });\n      this.upgrading = true;\n      // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n      try {\n        this._socket = tls.connect(opts, function () {\n          _this7.secure = true;\n          _this7.upgrading = false;\n          _this7._socket.on('data', _this7._onSocketData);\n          socketPlain.removeListener('close', _this7._onSocketClose);\n          socketPlain.removeListener('end', _this7._onSocketEnd);\n          return callback(null, true);\n        });\n      } catch (err) {\n        return callback(err);\n      }\n      this._socket.on('error', this._onSocketError);\n      this._socket.once('close', this._onSocketClose);\n      this._socket.once('end', this._onSocketEnd);\n      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n      this._socket.on('timeout', this._onSocketTimeout);\n\n      // resume in case the socket was paused\n      socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n  }, {\n    key: \"_processResponse\",\n    value: function _processResponse() {\n      var _this8 = this;\n      if (!this._responseQueue.length) {\n        return false;\n      }\n      var str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n      if (/^\\d+-/.test(str.split('\\n').pop())) {\n        // keep waiting for the final part of multiline response\n        return;\n      }\n      if (this.options.debug || this.options.transactionLog) {\n        this.logger.debug({\n          tnx: 'server'\n        }, str.replace(/\\r?\\n$/, ''));\n      }\n      if (!str.trim()) {\n        // skip unexpected empty lines\n        setImmediate(function () {\n          return _this8._processResponse(true);\n        });\n      }\n      var action = this._responseActions.shift();\n      if (typeof action === 'function') {\n        action.call(this, str);\n        setImmediate(function () {\n          return _this8._processResponse(true);\n        });\n      } else {\n        return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n      }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     * @param {String} logStr Optional string to be used for logging instead of the actual string\n     */\n  }, {\n    key: \"_sendCommand\",\n    value: function _sendCommand(str, logStr) {\n      if (this._destroyed) {\n        // Connection already closed, can't send any more data\n        return;\n      }\n      if (this._socket.destroyed) {\n        return this.close();\n      }\n      if (this.options.debug || this.options.transactionLog) {\n        this.logger.debug({\n          tnx: 'client'\n        }, (logStr || str || '').toString().replace(/\\r?\\n$/, ''));\n      }\n      this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n  }, {\n    key: \"_setEnvelope\",\n    value: function _setEnvelope(envelope, callback) {\n      var _this9 = this;\n      var args = [];\n      var useSmtpUtf8 = false;\n      this._envelope = envelope || {};\n      this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n      this._envelope.to = [].concat(this._envelope.to || []).map(function (to) {\n        return (to && to.address || to || '').toString().trim();\n      });\n      if (!this._envelope.to.length) {\n        return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n      }\n      if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n        return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n      }\n\n      // check if the sender address uses only ASCII characters,\n      // otherwise require usage of SMTPUTF8 extension\n      if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        useSmtpUtf8 = true;\n      }\n      for (var i = 0, len = this._envelope.to.length; i < len; i++) {\n        if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n          return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the recipients addresses use only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n          useSmtpUtf8 = true;\n        }\n      }\n\n      // clone the recipients array for latter manipulation\n      this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n      this._envelope.rejected = [];\n      this._envelope.rejectedErrors = [];\n      this._envelope.accepted = [];\n      if (this._envelope.dsn) {\n        try {\n          this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n        } catch (err) {\n          return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n        }\n      }\n      this._responseActions.push(function (str) {\n        _this9._actionMAIL(str, callback);\n      });\n\n      // If the server supports SMTPUTF8 and the envelope includes an internationalized\n      // email address then append SMTPUTF8 keyword to the MAIL FROM command\n      if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n        args.push('SMTPUTF8');\n        this._usingSmtpUtf8 = true;\n      }\n\n      // If the server supports 8BITMIME and the message might contain non-ascii bytes\n      // then append the 8BITMIME keyword to the MAIL FROM command\n      if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n        args.push('BODY=8BITMIME');\n        this._using8BitMime = true;\n      }\n      if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n        args.push('SIZE=' + this._envelope.size);\n      }\n\n      // If the server supports DSN and the envelope includes an DSN prop\n      // then append DSN params to the MAIL FROM command\n      if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n        if (this._envelope.dsn.ret) {\n          args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n        }\n        if (this._envelope.dsn.envid) {\n          args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n        }\n      }\n      this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n  }, {\n    key: \"_setDsnEnvelope\",\n    value: function _setDsnEnvelope(params) {\n      var ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n      if (ret) {\n        switch (ret) {\n          case 'HDRS':\n          case 'HEADERS':\n            ret = 'HDRS';\n            break;\n          case 'FULL':\n          case 'BODY':\n            ret = 'FULL';\n            break;\n        }\n      }\n      if (ret && !['FULL', 'HDRS'].includes(ret)) {\n        throw new Error('ret: ' + JSON.stringify(ret));\n      }\n      var envid = (params.envid || params.id || '').toString() || null;\n      var notify = params.notify || null;\n      if (notify) {\n        if (typeof notify === 'string') {\n          notify = notify.split(',');\n        }\n        notify = notify.map(function (n) {\n          return n.trim().toUpperCase();\n        });\n        var validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n        var invaliNotify = notify.filter(function (n) {\n          return !validNotify.includes(n);\n        });\n        if (invaliNotify.length || notify.length > 1 && notify.includes('NEVER')) {\n          throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n        }\n        notify = notify.join(',');\n      }\n      var orcpt = (params.recipient || params.orcpt || '').toString() || null;\n      if (orcpt && orcpt.indexOf(';') < 0) {\n        orcpt = 'rfc822;' + orcpt;\n      }\n      return {\n        ret: ret,\n        envid: envid,\n        notify: notify,\n        orcpt: orcpt\n      };\n    }\n  }, {\n    key: \"_getDsnRcptToArgs\",\n    value: function _getDsnRcptToArgs() {\n      var args = [];\n      // If the server supports DSN and the envelope includes an DSN prop\n      // then append DSN params to the RCPT TO command\n      if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n        if (this._envelope.dsn.notify) {\n          args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n        }\n        if (this._envelope.dsn.orcpt) {\n          args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n        }\n      }\n      return args.length ? ' ' + args.join(' ') : '';\n    }\n  }, {\n    key: \"_createSendStream\",\n    value: function _createSendStream(callback) {\n      var _this10 = this;\n      var dataStream = new DataStream();\n      var logStream;\n      if (this.options.lmtp) {\n        this._envelope.accepted.forEach(function (recipient, i) {\n          var final = i === _this10._envelope.accepted.length - 1;\n          _this10._responseActions.push(function (str) {\n            _this10._actionLMTPStream(recipient, final, str, callback);\n          });\n        });\n      } else {\n        this._responseActions.push(function (str) {\n          _this10._actionSMTPStream(str, callback);\n        });\n      }\n      dataStream.pipe(this._socket, {\n        end: false\n      });\n      if (this.options.debug) {\n        logStream = new PassThrough();\n        logStream.on('readable', function () {\n          var chunk;\n          while (chunk = logStream.read()) {\n            _this10.logger.debug({\n              tnx: 'message'\n            }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n          }\n        });\n        dataStream.pipe(logStream);\n      }\n      dataStream.once('end', function () {\n        _this10.logger.info({\n          tnx: 'message',\n          inByteCount: dataStream.inByteCount,\n          outByteCount: dataStream.outByteCount\n        }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n      });\n      return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionGreeting\",\n    value: function _actionGreeting(str) {\n      clearTimeout(this._greetingTimeout);\n      if (str.substr(0, 3) !== '220') {\n        this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n        return;\n      }\n      if (this.options.lmtp) {\n        this._responseActions.push(this._actionLHLO);\n        this._sendCommand('LHLO ' + this.name);\n      } else {\n        this._responseActions.push(this._actionEHLO);\n        this._sendCommand('EHLO ' + this.name);\n      }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionLHLO\",\n    value: function _actionLHLO(str) {\n      if (str.charAt(0) !== '2') {\n        this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n        return;\n      }\n      this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionEHLO\",\n    value: function _actionEHLO(str) {\n      var match;\n      if (str.substr(0, 3) === '421') {\n        this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n        return;\n      }\n      if (str.charAt(0) !== '2') {\n        if (this.options.requireTLS) {\n          this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n          return;\n        }\n\n        // Try HELO instead\n        this._responseActions.push(this._actionHELO);\n        this._sendCommand('HELO ' + this.name);\n        return;\n      }\n      this._ehloLines = str.split(/\\r?\\n/).map(function (line) {\n        return line.replace(/^\\d+[ -]/, '').trim();\n      }).filter(function (line) {\n        return line;\n      }).slice(1);\n\n      // Detect if the server supports STARTTLS\n      if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n        this._sendCommand('STARTTLS');\n        this._responseActions.push(this._actionSTARTTLS);\n        return;\n      }\n\n      // Detect if the server supports SMTPUTF8\n      if (/[ -]SMTPUTF8\\b/im.test(str)) {\n        this._supportedExtensions.push('SMTPUTF8');\n      }\n\n      // Detect if the server supports DSN\n      if (/[ -]DSN\\b/im.test(str)) {\n        this._supportedExtensions.push('DSN');\n      }\n\n      // Detect if the server supports 8BITMIME\n      if (/[ -]8BITMIME\\b/im.test(str)) {\n        this._supportedExtensions.push('8BITMIME');\n      }\n\n      // Detect if the server supports PIPELINING\n      if (/[ -]PIPELINING\\b/im.test(str)) {\n        this._supportedExtensions.push('PIPELINING');\n      }\n\n      // Detect if the server supports AUTH\n      if (/[ -]AUTH\\b/i.test(str)) {\n        this.allowsAuth = true;\n      }\n\n      // Detect if the server supports PLAIN auth\n      if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n        this._supportedAuth.push('PLAIN');\n      }\n\n      // Detect if the server supports LOGIN auth\n      if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n        this._supportedAuth.push('LOGIN');\n      }\n\n      // Detect if the server supports CRAM-MD5 auth\n      if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n        this._supportedAuth.push('CRAM-MD5');\n      }\n\n      // Detect if the server supports XOAUTH2 auth\n      if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n        this._supportedAuth.push('XOAUTH2');\n      }\n\n      // Detect if the server supports SIZE extensions (and the max allowed size)\n      if (match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im)) {\n        this._supportedExtensions.push('SIZE');\n        this._maxAllowedSize = Number(match[1]) || 0;\n      }\n      this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionHELO\",\n    value: function _actionHELO(str) {\n      if (str.charAt(0) !== '2') {\n        this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n        return;\n      }\n\n      // assume that authentication is enabled (most probably is not though)\n      this.allowsAuth = true;\n      this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionSTARTTLS\",\n    value: function _actionSTARTTLS(str) {\n      var _this11 = this;\n      if (str.charAt(0) !== '2') {\n        if (this.options.opportunisticTLS) {\n          this.logger.info({\n            tnx: 'smtp'\n          }, 'Failed STARTTLS upgrade, continuing unencrypted');\n          return this.emit('connect');\n        }\n        this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n        return;\n      }\n      this._upgradeConnection(function (err, secured) {\n        if (err) {\n          _this11._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n          return;\n        }\n        _this11.logger.info({\n          tnx: 'smtp'\n        }, 'Connection upgraded with STARTTLS');\n        if (secured) {\n          // restart session\n          if (_this11.options.lmtp) {\n            _this11._responseActions.push(_this11._actionLHLO);\n            _this11._sendCommand('LHLO ' + _this11.name);\n          } else {\n            _this11._responseActions.push(_this11._actionEHLO);\n            _this11._sendCommand('EHLO ' + _this11.name);\n          }\n        } else {\n          _this11.emit('connect');\n        }\n      });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionAUTH_LOGIN_USER\",\n    value: function _actionAUTH_LOGIN_USER(str, callback) {\n      var _this12 = this;\n      if (!/^334[ -]/.test(str)) {\n        // expecting '334 VXNlcm5hbWU6'\n        callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        return;\n      }\n      this._responseActions.push(function (str) {\n        _this12._actionAUTH_LOGIN_PASS(str, callback);\n      });\n      this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionAUTH_CRAM_MD5\",\n    value: function _actionAUTH_CRAM_MD5(str, callback) {\n      var _this13 = this;\n      var challengeMatch = str.match(/^334\\s+(.+)$/);\n      var challengeString = '';\n      if (!challengeMatch) {\n        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n      } else {\n        challengeString = challengeMatch[1];\n      }\n\n      // Decode from base64\n      var base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n        hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n      hmacMD5.update(base64decoded);\n      var prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n      this._responseActions.push(function (str) {\n        _this13._actionAUTH_CRAM_MD5_PASS(str, callback);\n      });\n      this._sendCommand(Buffer.from(prepended).toString('base64'),\n      // hidden hash for logs\n      Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64'));\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionAUTH_CRAM_MD5_PASS\",\n    value: function _actionAUTH_CRAM_MD5_PASS(str, callback) {\n      if (!str.match(/^235\\s+/)) {\n        return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n      }\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authenticated',\n        method: this._authMethod\n      }, 'User %s authenticated', JSON.stringify(this._auth.user));\n      this.authenticated = true;\n      callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionAUTH_LOGIN_PASS\",\n    value: function _actionAUTH_LOGIN_PASS(str, callback) {\n      var _this14 = this;\n      if (!/^334[ -]/.test(str)) {\n        // expecting '334 UGFzc3dvcmQ6'\n        return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n      }\n      this._responseActions.push(function (str) {\n        _this14._actionAUTHComplete(str, callback);\n      });\n      this._sendCommand(Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n      // Hidden pass for logs\n      Buffer.from('/* secret */', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionAUTHComplete\",\n    value: function _actionAUTHComplete(str, isRetry, callback) {\n      var _this15 = this;\n      if (!callback && typeof isRetry === 'function') {\n        callback = isRetry;\n        isRetry = false;\n      }\n      if (str.substr(0, 3) === '334') {\n        this._responseActions.push(function (str) {\n          if (isRetry || _this15._authMethod !== 'XOAUTH2') {\n            _this15._actionAUTHComplete(str, true, callback);\n          } else {\n            // fetch a new OAuth2 access token\n            setImmediate(function () {\n              return _this15._handleXOauth2Token(true, callback);\n            });\n          }\n        });\n        this._sendCommand('');\n        return;\n      }\n      if (str.charAt(0) !== '2') {\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authfail',\n          method: this._authMethod\n        }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n        return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n      }\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authenticated',\n        method: this._authMethod\n      }, 'User %s authenticated', JSON.stringify(this._auth.user));\n      this.authenticated = true;\n      callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionMAIL\",\n    value: function _actionMAIL(str, callback) {\n      var _this16 = this;\n      var message, curRecipient;\n      if (Number(str.charAt(0)) !== 2) {\n        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n          message = 'Internationalized mailbox name not allowed';\n        } else {\n          message = 'Mail command failed';\n        }\n        return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n      }\n      if (!this._envelope.rcptQueue.length) {\n        return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n      } else {\n        this._recipientQueue = [];\n        if (this._supportedExtensions.includes('PIPELINING')) {\n          while (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(function (str) {\n              _this16._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n          }\n        } else {\n          curRecipient = this._envelope.rcptQueue.shift();\n          this._recipientQueue.push(curRecipient);\n          this._responseActions.push(function (str) {\n            _this16._actionRCPT(str, callback);\n          });\n          this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n      }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionRCPT\",\n    value: function _actionRCPT(str, callback) {\n      var _this17 = this;\n      var message,\n        err,\n        curRecipient = this._recipientQueue.shift();\n      if (Number(str.charAt(0)) !== 2) {\n        // this is a soft error\n        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n          message = 'Internationalized mailbox name not allowed';\n        } else {\n          message = 'Recipient command failed';\n        }\n        this._envelope.rejected.push(curRecipient);\n        // store error for the failed recipient\n        err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n        err.recipient = curRecipient;\n        this._envelope.rejectedErrors.push(err);\n      } else {\n        this._envelope.accepted.push(curRecipient);\n      }\n      if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n        if (this._envelope.rejected.length < this._envelope.to.length) {\n          this._responseActions.push(function (str) {\n            _this17._actionDATA(str, callback);\n          });\n          this._sendCommand('DATA');\n        } else {\n          err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n          err.rejected = this._envelope.rejected;\n          err.rejectedErrors = this._envelope.rejectedErrors;\n          return callback(err);\n        }\n      } else if (this._envelope.rcptQueue.length) {\n        curRecipient = this._envelope.rcptQueue.shift();\n        this._recipientQueue.push(curRecipient);\n        this._responseActions.push(function (str) {\n          _this17._actionRCPT(str, callback);\n        });\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n      }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionDATA\",\n    value: function _actionDATA(str, callback) {\n      // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n      // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n      if (!/^[23]/.test(str)) {\n        return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n      }\n      var response = {\n        accepted: this._envelope.accepted,\n        rejected: this._envelope.rejected\n      };\n      if (this._ehloLines && this._ehloLines.length) {\n        response.ehlo = this._ehloLines;\n      }\n      if (this._envelope.rejectedErrors.length) {\n        response.rejectedErrors = this._envelope.rejectedErrors;\n      }\n      callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionSMTPStream\",\n    value: function _actionSMTPStream(str, callback) {\n      if (Number(str.charAt(0)) !== 2) {\n        // Message failed\n        return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n      } else {\n        // Message sent succesfully\n        return callback(null, str);\n      }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n  }, {\n    key: \"_actionLMTPStream\",\n    value: function _actionLMTPStream(recipient, final, str, callback) {\n      var err;\n      if (Number(str.charAt(0)) !== 2) {\n        // Message failed\n        err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n        err.recipient = recipient;\n        this._envelope.rejected.push(recipient);\n        this._envelope.rejectedErrors.push(err);\n        for (var i = 0, len = this._envelope.accepted.length; i < len; i++) {\n          if (this._envelope.accepted[i] === recipient) {\n            this._envelope.accepted.splice(i, 1);\n          }\n        }\n      }\n      if (final) {\n        return callback(null, str);\n      }\n    }\n  }, {\n    key: \"_handleXOauth2Token\",\n    value: function _handleXOauth2Token(isRetry, callback) {\n      var _this18 = this;\n      this._auth.oauth2.getToken(isRetry, function (err, accessToken) {\n        if (err) {\n          _this18.logger.info({\n            tnx: 'smtp',\n            username: _this18._auth.user,\n            action: 'authfail',\n            method: _this18._authMethod\n          }, 'User %s failed to authenticate', JSON.stringify(_this18._auth.user));\n          return callback(_this18._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n        }\n        _this18._responseActions.push(function (str) {\n          _this18._actionAUTHComplete(str, isRetry, callback);\n        });\n        _this18._sendCommand('AUTH XOAUTH2 ' + _this18._auth.oauth2.buildXOAuth2Token(accessToken),\n        //  Hidden for logs\n        'AUTH XOAUTH2 ' + _this18._auth.oauth2.buildXOAuth2Token('/* secret */'));\n      });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n  }, {\n    key: \"_isDestroyedMessage\",\n    value: function _isDestroyedMessage(command) {\n      if (this._destroyed) {\n        return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n      }\n      if (this._socket) {\n        if (this._socket.destroyed) {\n          return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n        }\n        if (!this._socket.writable) {\n          return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n        }\n      }\n    }\n  }, {\n    key: \"_getHostname\",\n    value: function _getHostname() {\n      // defaul hostname is machine hostname or [IP]\n      var defaultHostname;\n      try {\n        defaultHostname = os.hostname() || '';\n      } catch (err) {\n        // fails on windows 7\n        defaultHostname = 'localhost';\n      }\n\n      // ignore if not FQDN\n      if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n        defaultHostname = '[127.0.0.1]';\n      }\n\n      // IP should be enclosed in []\n      if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n        defaultHostname = '[' + defaultHostname + ']';\n      }\n      return defaultHostname;\n    }\n  }]);\n  return SMTPConnection;\n}(EventEmitter);\nmodule.exports = SMTPConnection;","map":{"version":3,"names":["packageInfo","require","EventEmitter","net","tls","os","crypto","DataStream","PassThrough","shared","CONNECTION_TIMEOUT","SOCKET_TIMEOUT","GREETING_TIMEOUT","DNS_TIMEOUT","SMTPConnection","options","id","randomBytes","toString","replace","stage","secureConnection","secure","alreadySecured","secured","port","Number","host","allowInternalNetworkInterfaces","name","_getHostname","logger","getLogger","component","sid","customAuth","Map","Object","keys","forEach","key","mapKey","trim","toUpperCase","set","version","authenticated","destroyed","_remainder","_responseQueue","lastServerResponse","_socket","_supportedAuth","allowsAuth","_envelope","_supportedExtensions","_maxAllowedSize","_responseActions","_recipientQueue","_greetingTimeout","_connectionTimeout","_destroyed","_closing","_onSocketData","chunk","_onData","_onSocketError","error","_onError","_onSocketClose","_onClose","_onSocketEnd","_onEnd","_onSocketTimeout","_onTimeout","connectCallback","once","debug","tnx","isDestroyedMessage","_isDestroyedMessage","_formatError","opts","timeout","dnsTimeout","localAddress","setupConnectionHandlers","setTimeout","connectionTimeout","on","connection","setImmediate","_upgradeConnection","err","Error","message","_onConnect","socket","resolveHostname","resolved","source","cached","charAt","connect","setKeepAlive","E","_sendCommand","push","close","clearTimeout","closeMethod","_destroy","authData","callback","_auth","_authMethod","method","oauth2","credentials","user","pass","has","handler","get","lastResponse","returned","resolve","info","username","action","JSON","stringify","reject","handlerResponse","auth","extensions","concat","authMethods","maxAllowedSize","sendCommand","cmd","done","promise","Promise","callbackPromise","str","codes","match","data","command","response","status","code","text","substr","length","catch","then","_handleXOauth2Token","_actionAUTH_LOGIN_USER","_actionAUTHComplete","Buffer","from","_actionAUTH_CRAM_MD5","envelope","size","arguments","startTime","Date","now","_setEnvelope","envelopeTime","stream","_createSendStream","messageTime","messageSize","outByteCount","pipe","write","end","localPort","remoteAddress","remotePort","removeListener","socketTimeout","_actionGreeting","greetingTimeout","resume","lines","split","lastline","pop","i","len","test","_processResponse","type","emit","prototype","call","responseCode","upgrading","includes","destroy","socketPlain","shift","transactionLog","logStr","args","useSmtpUtf8","address","to","map","rcptQueue","parse","rejected","rejectedErrors","accepted","dsn","_setDsnEnvelope","_actionMAIL","_usingSmtpUtf8","use8BitMime","_using8BitMime","ret","encodeXText","envid","join","params","return","notify","n","validNotify","invaliNotify","filter","orcpt","recipient","indexOf","dataStream","logStream","lmtp","final","_actionLMTPStream","_actionSMTPStream","read","inByteCount","_actionLHLO","_actionEHLO","requireTLS","_actionHELO","_ehloLines","line","slice","ignoreTLS","_actionSTARTTLS","opportunisticTLS","_actionAUTH_LOGIN_PASS","challengeMatch","challengeString","base64decoded","hmacMD5","createHmac","update","prepended","digest","_actionAUTH_CRAM_MD5_PASS","isRetry","curRecipient","_actionRCPT","_getDsnRcptToArgs","_actionDATA","ehlo","splice","getToken","accessToken","buildXOAuth2Token","writable","defaultHostname","hostname","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/smtp-connection/index.js"],"sourcesContent":["'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        this.customAuth = new Map();\n        Object.keys(this.options.customAuth || {}).forEach(key => {\n            let mapKey = (key || '').toString().trim().toUpperCase();\n            if (!mapKey) {\n                return;\n            }\n            this.customAuth.set(mapKey, this.options.customAuth[key]);\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Set to true, if EHLO response includes \"AUTH\".\n         * If false then authentication is not tried\n         */\n        this.allowsAuth = false;\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n\n        /**\n         * Callbacks for socket's listeners\n         */\n        this._onSocketData = chunk => this._onData(chunk);\n        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n        this._onSocketClose = () => this._onClose();\n        this._onSocketEnd = () => this._onEnd();\n        this._onSocketTimeout = () => this._onTimeout();\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host,\n            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n            timeout: this.options.dnsTimeout || DNS_TIMEOUT\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        let setupConnectionHandlers = () => {\n            this._connectionTimeout = setTimeout(() => {\n                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n            this._socket.on('error', this._onSocketError);\n        };\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n            return;\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket.connect(this.port, this.host, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = tls.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else {\n            // connect using plaintext\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = net.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n        // Select SASL authentication method\n        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if (this._auth.user && this._auth.pass) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass,\n                    options: this._auth.options\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        if (this.customAuth.has(this._authMethod)) {\n            let handler = this.customAuth.get(this._authMethod);\n            let lastResponse;\n            let returned = false;\n\n            let resolve = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authenticated',\n                        method: this._authMethod\n                    },\n                    'User %s authenticated',\n                    JSON.stringify(this._auth.user)\n                );\n                this.authenticated = true;\n                callback(null, true);\n            };\n\n            let reject = err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n            };\n\n            let handlerResponse = handler({\n                auth: this._auth,\n                method: this._authMethod,\n\n                extensions: [].concat(this._supportedExtensions),\n                authMethods: [].concat(this._supportedAuth),\n                maxAllowedSize: this._maxAllowedSize || false,\n\n                sendCommand: (cmd, done) => {\n                    let promise;\n\n                    if (!done) {\n                        promise = new Promise((resolve, reject) => {\n                            done = shared.callbackPromise(resolve, reject);\n                        });\n                    }\n\n                    this._responseActions.push(str => {\n                        lastResponse = str;\n\n                        let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n                        let data = {\n                            command: cmd,\n                            response: str\n                        };\n                        if (codes) {\n                            data.status = Number(codes[1]) || 0;\n                            if (codes[2]) {\n                                data.code = codes[2];\n                            }\n                            data.text = str.substr(codes[0].length);\n                        } else {\n                            data.text = str;\n                            data.status = 0; // just in case we need to perform numeric comparisons\n                        }\n                        done(null, data);\n                    });\n                    setImmediate(() => this._sendCommand(cmd));\n\n                    return promise;\n                },\n\n                resolve,\n                reject\n            });\n\n            if (handlerResponse && typeof handlerResponse.catch === 'function') {\n                // a promise was returned\n                handlerResponse.then(resolve).catch(reject);\n            }\n\n            return;\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64'),\n                    // log entry without passwords\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                '/* secret */',\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeListener('data', this._onSocketData);\n        this._socket.removeListener('timeout', this._onSocketTimeout);\n        this._socket.removeListener('close', this._onSocketClose);\n        this._socket.removeListener('end', this._onSocketEnd);\n\n        this._socket.on('data', this._onSocketData);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                return;\n            }\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        if (this._socket && !this._socket.destroyed) {\n            this._socket.destroy();\n        }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        this.upgrading = true;\n        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n        try {\n            this._socket = tls.connect(opts, () => {\n                this.secure = true;\n                this.upgrading = false;\n                this._socket.on('data', this._onSocketData);\n\n                socketPlain.removeListener('close', this._onSocketClose);\n                socketPlain.removeListener('end', this._onSocketEnd);\n\n                return callback(null, true);\n            });\n        } catch (err) {\n            return callback(err);\n        }\n\n        this._socket.on('error', this._onSocketError);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse(true));\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse(true));\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     * @param {String} logStr Optional string to be used for logging instead of the actual string\n     */\n    _sendCommand(str, logStr) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (logStr || str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        this._ehloLines = str\n            .split(/\\r?\\n/)\n            .map(line => line.replace(/^\\d+[ -]/, '').trim())\n            .filter(line => line)\n            .slice(1);\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports AUTH\n        if (/[ -]AUTH\\b/i.test(str)) {\n            this.allowsAuth = true;\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        // assume that authentication is enabled (most probably is not though)\n        this.allowsAuth = true;\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmacMD5.update(base64decoded);\n\n        let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from(prepended).toString('base64'),\n            // hidden hash for logs\n            Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n            // Hidden pass for logs\n            Buffer.from('/* secret */', 'utf-8').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._ehloLines && this._ehloLines.length) {\n            response.ehlo = this._ehloLines;\n        }\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand(\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),\n                //  Hidden for logs\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */')\n            );\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname;\n        try {\n            defaultHostname = os.hostname() || '';\n        } catch (err) {\n            // fails on windows 7\n            defaultHostname = 'localhost';\n        }\n\n        // ignore if not FQDN\n        if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}