{"ast":null,"code":"'use strict';\n\n// module to handle cookies\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar urllib = require('url');\nvar SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nvar Cookies = /*#__PURE__*/function () {\n  function Cookies(options) {\n    _classCallCheck(this, Cookies);\n    this.options = options || {};\n    this.cookies = [];\n  }\n\n  /**\n   * Stores a cookie string to the cookie storage\n   *\n   * @param {String} cookieStr Value from the 'Set-Cookie:' header\n   * @param {String} url Current URL\n   */\n  _createClass(Cookies, [{\n    key: \"set\",\n    value: function set(cookieStr, url) {\n      var urlparts = urllib.parse(url || '');\n      var cookie = this.parse(cookieStr);\n      var domain;\n      if (cookie.domain) {\n        domain = cookie.domain.replace(/^\\./, '');\n\n        // do not allow cross origin cookies\n        if (\n        // can't be valid if the requested domain is shorter than current hostname\n        urlparts.hostname.length < domain.length ||\n        // prefix domains with dot to be sure that partial matches are not used\n        ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain) {\n          cookie.domain = urlparts.hostname;\n        }\n      } else {\n        cookie.domain = urlparts.hostname;\n      }\n      if (!cookie.path) {\n        cookie.path = this.getPath(urlparts.pathname);\n      }\n\n      // if no expire date, then use sessionTimeout value\n      if (!cookie.expires) {\n        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n      }\n      return this.add(cookie);\n    }\n\n    /**\n     * Returns cookie string for the 'Cookie:' header.\n     *\n     * @param {String} url URL to check for\n     * @returns {String} Cookie header or empty string if no matches were found\n     */\n  }, {\n    key: \"get\",\n    value: function get(url) {\n      return this.list(url).map(function (cookie) {\n        return cookie.name + '=' + cookie.value;\n      }).join('; ');\n    }\n\n    /**\n     * Lists all valied cookie objects for the specified URL\n     *\n     * @param {String} url URL to check for\n     * @returns {Array} An array of cookie objects\n     */\n  }, {\n    key: \"list\",\n    value: function list(url) {\n      var result = [];\n      var i;\n      var cookie;\n      for (i = this.cookies.length - 1; i >= 0; i--) {\n        cookie = this.cookies[i];\n        if (this.isExpired(cookie)) {\n          this.cookies.splice(i, i);\n          continue;\n        }\n        if (this.match(cookie, url)) {\n          result.unshift(cookie);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Parses cookie string from the 'Set-Cookie:' header\n     *\n     * @param {String} cookieStr String from the 'Set-Cookie:' header\n     * @returns {Object} Cookie object\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(cookieStr) {\n      var cookie = {};\n      (cookieStr || '').toString().split(';').forEach(function (cookiePart) {\n        var valueParts = cookiePart.split('=');\n        var key = valueParts.shift().trim().toLowerCase();\n        var value = valueParts.join('=').trim();\n        var domain;\n        if (!key) {\n          // skip empty parts\n          return;\n        }\n        switch (key) {\n          case 'expires':\n            value = new Date(value);\n            // ignore date if can not parse it\n            if (value.toString() !== 'Invalid Date') {\n              cookie.expires = value;\n            }\n            break;\n          case 'path':\n            cookie.path = value;\n            break;\n          case 'domain':\n            domain = value.toLowerCase();\n            if (domain.length && domain.charAt(0) !== '.') {\n              domain = '.' + domain; // ensure preceeding dot for user set domains\n            }\n\n            cookie.domain = domain;\n            break;\n          case 'max-age':\n            cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n            break;\n          case 'secure':\n            cookie.secure = true;\n            break;\n          case 'httponly':\n            cookie.httponly = true;\n            break;\n          default:\n            if (!cookie.name) {\n              cookie.name = key;\n              cookie.value = value;\n            }\n        }\n      });\n      return cookie;\n    }\n\n    /**\n     * Checks if a cookie object is valid for a specified URL\n     *\n     * @param {Object} cookie Cookie object\n     * @param {String} url URL to check for\n     * @returns {Boolean} true if cookie is valid for specifiec URL\n     */\n  }, {\n    key: \"match\",\n    value: function match(cookie, url) {\n      var urlparts = urllib.parse(url || '');\n\n      // check if hostname matches\n      // .foo.com also matches subdomains, foo.com does not\n      if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {\n        return false;\n      }\n\n      // check if path matches\n      var path = this.getPath(urlparts.pathname);\n      if (path.substr(0, cookie.path.length) !== cookie.path) {\n        return false;\n      }\n\n      // check secure argument\n      if (cookie.secure && urlparts.protocol !== 'https:') {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * Adds (or updates/removes if needed) a cookie object to the cookie storage\n     *\n     * @param {Object} cookie Cookie value to be stored\n     */\n  }, {\n    key: \"add\",\n    value: function add(cookie) {\n      var i;\n      var len;\n\n      // nothing to do here\n      if (!cookie || !cookie.name) {\n        return false;\n      }\n\n      // overwrite if has same params\n      for (i = 0, len = this.cookies.length; i < len; i++) {\n        if (this.compare(this.cookies[i], cookie)) {\n          // check if the cookie needs to be removed instead\n          if (this.isExpired(cookie)) {\n            this.cookies.splice(i, 1); // remove expired/unset cookie\n            return false;\n          }\n          this.cookies[i] = cookie;\n          return true;\n        }\n      }\n\n      // add as new if not already expired\n      if (!this.isExpired(cookie)) {\n        this.cookies.push(cookie);\n      }\n      return true;\n    }\n\n    /**\n     * Checks if two cookie objects are the same\n     *\n     * @param {Object} a Cookie to check against\n     * @param {Object} b Cookie to check against\n     * @returns {Boolean} True, if the cookies are the same\n     */\n  }, {\n    key: \"compare\",\n    value: function compare(a, b) {\n      return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n    }\n\n    /**\n     * Checks if a cookie is expired\n     *\n     * @param {Object} cookie Cookie object to check against\n     * @returns {Boolean} True, if the cookie is expired\n     */\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(cookie) {\n      return cookie.expires && cookie.expires < new Date() || !cookie.value;\n    }\n\n    /**\n     * Returns normalized cookie path for an URL path argument\n     *\n     * @param {String} pathname\n     * @returns {String} Normalized path\n     */\n  }, {\n    key: \"getPath\",\n    value: function getPath(pathname) {\n      var path = (pathname || '/').split('/');\n      path.pop(); // remove filename part\n      path = path.join('/').trim();\n\n      // ensure path prefix /\n      if (path.charAt(0) !== '/') {\n        path = '/' + path;\n      }\n\n      // ensure path suffix /\n      if (path.substr(-1) !== '/') {\n        path += '/';\n      }\n      return path;\n    }\n  }]);\n  return Cookies;\n}();\nmodule.exports = Cookies;","map":{"version":3,"names":["urllib","require","SESSION_TIMEOUT","Cookies","options","cookies","cookieStr","url","urlparts","parse","cookie","domain","replace","hostname","length","substr","path","getPath","pathname","expires","Date","now","Number","sessionTimeout","add","list","map","name","value","join","result","i","isExpired","splice","match","unshift","toString","split","forEach","cookiePart","valueParts","key","shift","trim","toLowerCase","charAt","secure","httponly","protocol","len","compare","push","a","b","pop","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/fetch/cookies.js"],"sourcesContent":["'use strict';\n\n// module to handle cookies\n\nconst urllib = require('url');\n\nconst SESSION_TIMEOUT = 1800; // 30 min\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nclass Cookies {\n    constructor(options) {\n        this.options = options || {};\n        this.cookies = [];\n    }\n\n    /**\n     * Stores a cookie string to the cookie storage\n     *\n     * @param {String} cookieStr Value from the 'Set-Cookie:' header\n     * @param {String} url Current URL\n     */\n    set(cookieStr, url) {\n        let urlparts = urllib.parse(url || '');\n        let cookie = this.parse(cookieStr);\n        let domain;\n\n        if (cookie.domain) {\n            domain = cookie.domain.replace(/^\\./, '');\n\n            // do not allow cross origin cookies\n            if (\n                // can't be valid if the requested domain is shorter than current hostname\n                urlparts.hostname.length < domain.length ||\n                // prefix domains with dot to be sure that partial matches are not used\n                ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain\n            ) {\n                cookie.domain = urlparts.hostname;\n            }\n        } else {\n            cookie.domain = urlparts.hostname;\n        }\n\n        if (!cookie.path) {\n            cookie.path = this.getPath(urlparts.pathname);\n        }\n\n        // if no expire date, then use sessionTimeout value\n        if (!cookie.expires) {\n            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n        }\n\n        return this.add(cookie);\n    }\n\n    /**\n     * Returns cookie string for the 'Cookie:' header.\n     *\n     * @param {String} url URL to check for\n     * @returns {String} Cookie header or empty string if no matches were found\n     */\n    get(url) {\n        return this.list(url)\n            .map(cookie => cookie.name + '=' + cookie.value)\n            .join('; ');\n    }\n\n    /**\n     * Lists all valied cookie objects for the specified URL\n     *\n     * @param {String} url URL to check for\n     * @returns {Array} An array of cookie objects\n     */\n    list(url) {\n        let result = [];\n        let i;\n        let cookie;\n\n        for (i = this.cookies.length - 1; i >= 0; i--) {\n            cookie = this.cookies[i];\n\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, i);\n                continue;\n            }\n\n            if (this.match(cookie, url)) {\n                result.unshift(cookie);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Parses cookie string from the 'Set-Cookie:' header\n     *\n     * @param {String} cookieStr String from the 'Set-Cookie:' header\n     * @returns {Object} Cookie object\n     */\n    parse(cookieStr) {\n        let cookie = {};\n\n        (cookieStr || '')\n            .toString()\n            .split(';')\n            .forEach(cookiePart => {\n                let valueParts = cookiePart.split('=');\n                let key = valueParts.shift().trim().toLowerCase();\n                let value = valueParts.join('=').trim();\n                let domain;\n\n                if (!key) {\n                    // skip empty parts\n                    return;\n                }\n\n                switch (key) {\n                    case 'expires':\n                        value = new Date(value);\n                        // ignore date if can not parse it\n                        if (value.toString() !== 'Invalid Date') {\n                            cookie.expires = value;\n                        }\n                        break;\n\n                    case 'path':\n                        cookie.path = value;\n                        break;\n\n                    case 'domain':\n                        domain = value.toLowerCase();\n                        if (domain.length && domain.charAt(0) !== '.') {\n                            domain = '.' + domain; // ensure preceeding dot for user set domains\n                        }\n                        cookie.domain = domain;\n                        break;\n\n                    case 'max-age':\n                        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                        break;\n\n                    case 'secure':\n                        cookie.secure = true;\n                        break;\n\n                    case 'httponly':\n                        cookie.httponly = true;\n                        break;\n\n                    default:\n                        if (!cookie.name) {\n                            cookie.name = key;\n                            cookie.value = value;\n                        }\n                }\n            });\n\n        return cookie;\n    }\n\n    /**\n     * Checks if a cookie object is valid for a specified URL\n     *\n     * @param {Object} cookie Cookie object\n     * @param {String} url URL to check for\n     * @returns {Boolean} true if cookie is valid for specifiec URL\n     */\n    match(cookie, url) {\n        let urlparts = urllib.parse(url || '');\n\n        // check if hostname matches\n        // .foo.com also matches subdomains, foo.com does not\n        if (\n            urlparts.hostname !== cookie.domain &&\n            (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)\n        ) {\n            return false;\n        }\n\n        // check if path matches\n        let path = this.getPath(urlparts.pathname);\n        if (path.substr(0, cookie.path.length) !== cookie.path) {\n            return false;\n        }\n\n        // check secure argument\n        if (cookie.secure && urlparts.protocol !== 'https:') {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Adds (or updates/removes if needed) a cookie object to the cookie storage\n     *\n     * @param {Object} cookie Cookie value to be stored\n     */\n    add(cookie) {\n        let i;\n        let len;\n\n        // nothing to do here\n        if (!cookie || !cookie.name) {\n            return false;\n        }\n\n        // overwrite if has same params\n        for (i = 0, len = this.cookies.length; i < len; i++) {\n            if (this.compare(this.cookies[i], cookie)) {\n                // check if the cookie needs to be removed instead\n                if (this.isExpired(cookie)) {\n                    this.cookies.splice(i, 1); // remove expired/unset cookie\n                    return false;\n                }\n\n                this.cookies[i] = cookie;\n                return true;\n            }\n        }\n\n        // add as new if not already expired\n        if (!this.isExpired(cookie)) {\n            this.cookies.push(cookie);\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if two cookie objects are the same\n     *\n     * @param {Object} a Cookie to check against\n     * @param {Object} b Cookie to check against\n     * @returns {Boolean} True, if the cookies are the same\n     */\n    compare(a, b) {\n        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n    }\n\n    /**\n     * Checks if a cookie is expired\n     *\n     * @param {Object} cookie Cookie object to check against\n     * @returns {Boolean} True, if the cookie is expired\n     */\n    isExpired(cookie) {\n        return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n    }\n\n    /**\n     * Returns normalized cookie path for an URL path argument\n     *\n     * @param {String} pathname\n     * @returns {String} Normalized path\n     */\n    getPath(pathname) {\n        let path = (pathname || '/').split('/');\n        path.pop(); // remove filename part\n        path = path.join('/').trim();\n\n        // ensure path prefix /\n        if (path.charAt(0) !== '/') {\n            path = '/' + path;\n        }\n\n        // ensure path suffix /\n        if (path.substr(-1) !== '/') {\n            path += '/';\n        }\n\n        return path;\n    }\n}\n\nmodule.exports = Cookies;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}