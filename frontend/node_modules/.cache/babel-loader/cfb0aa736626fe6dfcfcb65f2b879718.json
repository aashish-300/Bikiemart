{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar EventEmitter = require('events');\nvar SMTPConnection = require('../smtp-connection');\nvar wellKnown = require('../well-known');\nvar shared = require('../shared');\nvar XOAuth2 = require('../xoauth2');\nvar packageData = require('../../package.json');\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nvar SMTPTransport = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPTransport, _EventEmitter);\n  var _super = _createSuper(SMTPTransport);\n  function SMTPTransport(options) {\n    var _this;\n    _classCallCheck(this, SMTPTransport);\n    _this = _super.call(this);\n    options = options || {};\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n    var urlData;\n    var service = options.service;\n    if (typeof options.getSocket === 'function') {\n      _this.getSocket = options.getSocket;\n    }\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n    _this.options = shared.assign(false,\n    // create new object\n    options,\n    // regular options\n    urlData,\n    // url options\n    service && wellKnown(service) // wellknown options\n    );\n\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-transport'\n    });\n\n    // temporary object\n    var connection = new SMTPConnection(_this.options);\n    _this.name = 'SMTP';\n    _this.version = packageData.version + '[client:' + connection.version + ']';\n    if (_this.options.auth) {\n      _this.auth = _this.getAuth({});\n    }\n    return _this;\n  }\n\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n  _createClass(SMTPTransport, [{\n    key: \"getSocket\",\n    value: function getSocket(options, callback) {\n      // return immediatelly\n      return setImmediate(function () {\n        return callback(null, false);\n      });\n    }\n  }, {\n    key: \"getAuth\",\n    value: function getAuth(authOpts) {\n      var _this2 = this;\n      if (!authOpts) {\n        return this.auth;\n      }\n      var hasAuth = false;\n      var authData = {};\n      if (this.options.auth && typeof this.options.auth === 'object') {\n        Object.keys(this.options.auth).forEach(function (key) {\n          hasAuth = true;\n          authData[key] = _this2.options.auth[key];\n        });\n      }\n      if (authOpts && typeof authOpts === 'object') {\n        Object.keys(authOpts).forEach(function (key) {\n          hasAuth = true;\n          authData[key] = authOpts[key];\n        });\n      }\n      if (!hasAuth) {\n        return false;\n      }\n      switch ((authData.type || '').toString().toUpperCase()) {\n        case 'OAUTH2':\n          {\n            if (!authData.service && !authData.user) {\n              return false;\n            }\n            var oauth2 = new XOAuth2(authData, this.logger);\n            oauth2.provisionCallback = this.mailer && this.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n            oauth2.on('token', function (token) {\n              return _this2.mailer.emit('token', token);\n            });\n            oauth2.on('error', function (err) {\n              return _this2.emit('error', err);\n            });\n            return {\n              type: 'OAUTH2',\n              user: authData.user,\n              oauth2: oauth2,\n              method: 'XOAUTH2'\n            };\n          }\n        default:\n          return {\n            type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n            user: authData.user,\n            credentials: {\n              user: authData.user || '',\n              pass: authData.pass,\n              options: authData.options\n            },\n            method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false\n          };\n      }\n    }\n\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n  }, {\n    key: \"send\",\n    value: function send(mail, callback) {\n      var _this3 = this;\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n        var returned = false;\n        var options = _this3.options;\n        if (socketOptions && socketOptions.connection) {\n          _this3.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n\n          // only copy options if we need to modify it\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n        var connection = new SMTPConnection(options);\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n          var timer = setTimeout(function () {\n            if (returned) {\n              return;\n            }\n            returned = true;\n            // still have not returned, this means we have an unexpected connection close\n            var err = new Error('Unexpected socket close');\n            if (connection && connection._socket && connection._socket.upgrading) {\n              // starttls connection errors\n              err.code = 'ETLS';\n            }\n            callback(err);\n          }, 1000);\n          try {\n            timer.unref();\n          } catch (E) {\n            // Ignore. Happens on envs with non-node timer implementation\n          }\n        });\n        var sendMessage = function sendMessage() {\n          var envelope = mail.message.getEnvelope();\n          var messageId = mail.message.messageId();\n          var recipients = [].concat(envelope.to || []);\n          if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n          }\n          if (mail.data.dsn) {\n            envelope.dsn = mail.data.dsn;\n          }\n          _this3.logger.info({\n            tnx: 'send',\n            messageId: messageId\n          }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n          connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n            returned = true;\n            connection.close();\n            if (err) {\n              _this3.logger.error({\n                err: err,\n                tnx: 'send'\n              }, 'Send error for %s: %s', messageId, err.message);\n              return callback(err);\n            }\n            info.envelope = {\n              from: envelope.from,\n              to: envelope.to\n            };\n            info.messageId = messageId;\n            try {\n              return callback(null, info);\n            } catch (E) {\n              _this3.logger.error({\n                err: E,\n                tnx: 'callback'\n              }, 'Callback error for %s: %s', messageId, E.message);\n            }\n          });\n        };\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n          var auth = _this3.getAuth(mail.data.auth);\n          if (auth && (connection.allowsAuth || options.forceAuth)) {\n            connection.login(auth, function (err) {\n              if (auth && auth !== _this3.auth && auth.oauth2) {\n                auth.oauth2.removeAllListeners();\n              }\n              if (returned) {\n                return;\n              }\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n              sendMessage();\n            });\n          } else {\n            sendMessage();\n          }\n        });\n      });\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n  }, {\n    key: \"verify\",\n    value: function verify(callback) {\n      var _this4 = this;\n      var promise;\n      if (!callback) {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n        var options = _this4.options;\n        if (socketOptions && socketOptions.connection) {\n          _this4.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n        var connection = new SMTPConnection(options);\n        var returned = false;\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          return callback(new Error('Connection closed'));\n        });\n        var finalize = function finalize() {\n          if (returned) {\n            return;\n          }\n          returned = true;\n          connection.quit();\n          return callback(null, true);\n        };\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n          var authData = _this4.getAuth({});\n          if (authData && (connection.allowsAuth || options.forceAuth)) {\n            connection.login(authData, function (err) {\n              if (returned) {\n                return;\n              }\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n              finalize();\n            });\n          } else if (!authData && connection.allowsAuth && options.forceAuth) {\n            var _err = new Error('Authentication info was not provided');\n            _err.code = 'NoAuth';\n            returned = true;\n            connection.close();\n            return callback(_err);\n          } else {\n            finalize();\n          }\n        });\n      });\n      return promise;\n    }\n\n    /**\n     * Releases resources\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.auth && this.auth.oauth2) {\n        this.auth.oauth2.removeAllListeners();\n      }\n      this.emit('close');\n    }\n  }]);\n  return SMTPTransport;\n}(EventEmitter); // expose to the world\nmodule.exports = SMTPTransport;","map":{"version":3,"names":["EventEmitter","require","SMTPConnection","wellKnown","shared","XOAuth2","packageData","SMTPTransport","options","url","urlData","service","getSocket","parseConnectionUrl","assign","logger","getLogger","component","connection","name","version","auth","getAuth","callback","setImmediate","authOpts","hasAuth","authData","Object","keys","forEach","key","type","toString","toUpperCase","user","oauth2","provisionCallback","mailer","get","on","token","emit","err","method","credentials","pass","trim","authMethod","mail","socketOptions","returned","info","tnx","remoteAddress","remotePort","destHost","host","destPort","port","action","once","close","timer","setTimeout","Error","_socket","upgrading","code","unref","E","sendMessage","envelope","message","getEnvelope","messageId","recipients","concat","to","length","push","splice","data","dsn","join","send","createReadStream","error","from","connect","allowsAuth","forceAuth","login","removeAllListeners","promise","Promise","resolve","reject","callbackPromise","finalize","quit","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/smtp-transport/index.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst XOAuth2 = require('../xoauth2');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nclass SMTPTransport extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-transport'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        if (this.options.auth) {\n            this.auth = this.getAuth({});\n        }\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    getAuth(authOpts) {\n        if (!authOpts) {\n            return this.auth;\n        }\n\n        let hasAuth = false;\n        let authData = {};\n\n        if (this.options.auth && typeof this.options.auth === 'object') {\n            Object.keys(this.options.auth).forEach(key => {\n                hasAuth = true;\n                authData[key] = this.options.auth[key];\n            });\n        }\n\n        if (authOpts && typeof authOpts === 'object') {\n            Object.keys(authOpts).forEach(key => {\n                hasAuth = true;\n                authData[key] = authOpts[key];\n            });\n        }\n\n        if (!hasAuth) {\n            return false;\n        }\n\n        switch ((authData.type || '').toString().toUpperCase()) {\n            case 'OAUTH2': {\n                if (!authData.service && !authData.user) {\n                    return false;\n                }\n                let oauth2 = new XOAuth2(authData, this.logger);\n                oauth2.provisionCallback = (this.mailer && this.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;\n                oauth2.on('token', token => this.mailer.emit('token', token));\n                oauth2.on('error', err => this.emit('error', err));\n                return {\n                    type: 'OAUTH2',\n                    user: authData.user,\n                    oauth2,\n                    method: 'XOAUTH2'\n                };\n            }\n            default:\n                return {\n                    type: (authData.type || '').toString().toUpperCase() || 'LOGIN',\n                    user: authData.user,\n                    credentials: {\n                        user: authData.user || '',\n                        pass: authData.pass,\n                        options: authData.options\n                    },\n                    method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false\n                };\n        }\n    }\n\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let returned = false;\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                // only copy options if we need to modify it\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n\n                let timer = setTimeout(() => {\n                    if (returned) {\n                        return;\n                    }\n                    returned = true;\n                    // still have not returned, this means we have an unexpected connection close\n                    let err = new Error('Unexpected socket close');\n                    if (connection && connection._socket && connection._socket.upgrading) {\n                        // starttls connection errors\n                        err.code = 'ETLS';\n                    }\n                    callback(err);\n                }, 1000);\n\n                try {\n                    timer.unref();\n                } catch (E) {\n                    // Ignore. Happens on envs with non-node timer implementation\n                }\n            });\n\n            let sendMessage = () => {\n                let envelope = mail.message.getEnvelope();\n                let messageId = mail.message.messageId();\n\n                let recipients = [].concat(envelope.to || []);\n                if (recipients.length > 3) {\n                    recipients.push('...and ' + recipients.splice(2).length + ' more');\n                }\n\n                if (mail.data.dsn) {\n                    envelope.dsn = mail.data.dsn;\n                }\n\n                this.logger.info(\n                    {\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Sending message %s to <%s>',\n                    messageId,\n                    recipients.join(', ')\n                );\n\n                connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n                    returned = true;\n                    connection.close();\n                    if (err) {\n                        this.logger.error(\n                            {\n                                err,\n                                tnx: 'send'\n                            },\n                            'Send error for %s: %s',\n                            messageId,\n                            err.message\n                        );\n                        return callback(err);\n                    }\n                    info.envelope = {\n                        from: envelope.from,\n                        to: envelope.to\n                    };\n                    info.messageId = messageId;\n                    try {\n                        return callback(null, info);\n                    } catch (E) {\n                        this.logger.error(\n                            {\n                                err: E,\n                                tnx: 'callback'\n                            },\n                            'Callback error for %s: %s',\n                            messageId,\n                            E.message\n                        );\n                    }\n                });\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let auth = this.getAuth(mail.data.auth);\n\n                if (auth && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(auth, err => {\n                        if (auth && auth !== this.auth && auth.oauth2) {\n                            auth.oauth2.removeAllListeners();\n                        }\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        sendMessage();\n                    });\n                } else {\n                    sendMessage();\n                }\n            });\n        });\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback) {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let authData = this.getAuth({});\n\n                if (authData && (connection.allowsAuth || options.forceAuth)) {\n                    connection.login(authData, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else if (!authData && connection.allowsAuth && options.forceAuth) {\n                    let err = new Error('Authentication info was not provided');\n                    err.code = 'NoAuth';\n\n                    returned = true;\n                    connection.close();\n                    return callback(err);\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n\n    /**\n     * Releases resources\n     */\n    close() {\n        if (this.auth && this.auth.oauth2) {\n            this.auth.oauth2.removeAllListeners();\n        }\n        this.emit('close');\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPTransport;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}