{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar stream = require('stream');\nvar Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nvar DataStream = /*#__PURE__*/function (_Transform) {\n  _inherits(DataStream, _Transform);\n  var _super = _createSuper(DataStream);\n  function DataStream(options) {\n    var _this;\n    _classCallCheck(this, DataStream);\n    _this = _super.call(this, options);\n    // init Transform\n    _this.options = options || {};\n    _this._curLine = '';\n    _this.inByteCount = 0;\n    _this.outByteCount = 0;\n    _this.lastByte = false;\n    return _this;\n  }\n\n  /**\n   * Escapes dots\n   */\n  _createClass(DataStream, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, done) {\n      var chunks = [];\n      var chunklen = 0;\n      var i,\n        len,\n        lastPos = 0;\n      var buf;\n      if (!chunk || !chunk.length) {\n        return done();\n      }\n      if (typeof chunk === 'string') {\n        chunk = Buffer.from(chunk);\n      }\n      this.inByteCount += chunk.length;\n      for (i = 0, len = chunk.length; i < len; i++) {\n        if (chunk[i] === 0x2e) {\n          // .\n          if (i && chunk[i - 1] === 0x0a || !i && (!this.lastByte || this.lastByte === 0x0a)) {\n            buf = chunk.slice(lastPos, i + 1);\n            chunks.push(buf);\n            chunks.push(Buffer.from('.'));\n            chunklen += buf.length + 1;\n            lastPos = i + 1;\n          }\n        } else if (chunk[i] === 0x0a) {\n          // .\n          if (i && chunk[i - 1] !== 0x0d || !i && this.lastByte !== 0x0d) {\n            if (i > lastPos) {\n              buf = chunk.slice(lastPos, i);\n              chunks.push(buf);\n              chunklen += buf.length + 2;\n            } else {\n              chunklen += 2;\n            }\n            chunks.push(Buffer.from('\\r\\n'));\n            lastPos = i + 1;\n          }\n        }\n      }\n      if (chunklen) {\n        // add last piece\n        if (lastPos < chunk.length) {\n          buf = chunk.slice(lastPos);\n          chunks.push(buf);\n          chunklen += buf.length;\n        }\n        this.outByteCount += chunklen;\n        this.push(Buffer.concat(chunks, chunklen));\n      } else {\n        this.outByteCount += chunk.length;\n        this.push(chunk);\n      }\n      this.lastByte = chunk[chunk.length - 1];\n      done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n  }, {\n    key: \"_flush\",\n    value: function _flush(done) {\n      var buf;\n      if (this.lastByte === 0x0a) {\n        buf = Buffer.from('.\\r\\n');\n      } else if (this.lastByte === 0x0d) {\n        buf = Buffer.from('\\n.\\r\\n');\n      } else {\n        buf = Buffer.from('\\r\\n.\\r\\n');\n      }\n      this.outByteCount += buf.length;\n      this.push(buf);\n      done();\n    }\n  }]);\n  return DataStream;\n}(Transform);\nmodule.exports = DataStream;","map":{"version":3,"names":["stream","require","Transform","DataStream","options","_curLine","inByteCount","outByteCount","lastByte","chunk","encoding","done","chunks","chunklen","i","len","lastPos","buf","length","Buffer","from","slice","push","concat","module","exports"],"sources":["D:/fyp/Ecommerce_Bikiemart/frontend/node_modules/nodemailer/lib/smtp-connection/data-stream.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nclass DataStream extends Transform {\n    constructor(options) {\n        super(options);\n        // init Transform\n        this.options = options || {};\n        this._curLine = '';\n\n        this.inByteCount = 0;\n        this.outByteCount = 0;\n        this.lastByte = false;\n    }\n\n    /**\n     * Escapes dots\n     */\n    _transform(chunk, encoding, done) {\n        let chunks = [];\n        let chunklen = 0;\n        let i,\n            len,\n            lastPos = 0;\n        let buf;\n\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk);\n        }\n\n        this.inByteCount += chunk.length;\n\n        for (i = 0, len = chunk.length; i < len; i++) {\n            if (chunk[i] === 0x2e) {\n                // .\n                if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {\n                    buf = chunk.slice(lastPos, i + 1);\n                    chunks.push(buf);\n                    chunks.push(Buffer.from('.'));\n                    chunklen += buf.length + 1;\n                    lastPos = i + 1;\n                }\n            } else if (chunk[i] === 0x0a) {\n                // .\n                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {\n                    if (i > lastPos) {\n                        buf = chunk.slice(lastPos, i);\n                        chunks.push(buf);\n                        chunklen += buf.length + 2;\n                    } else {\n                        chunklen += 2;\n                    }\n                    chunks.push(Buffer.from('\\r\\n'));\n                    lastPos = i + 1;\n                }\n            }\n        }\n\n        if (chunklen) {\n            // add last piece\n            if (lastPos < chunk.length) {\n                buf = chunk.slice(lastPos);\n                chunks.push(buf);\n                chunklen += buf.length;\n            }\n\n            this.outByteCount += chunklen;\n            this.push(Buffer.concat(chunks, chunklen));\n        } else {\n            this.outByteCount += chunk.length;\n            this.push(chunk);\n        }\n\n        this.lastByte = chunk[chunk.length - 1];\n        done();\n    }\n\n    /**\n     * Finalizes the stream with a dot on a single line\n     */\n    _flush(done) {\n        let buf;\n        if (this.lastByte === 0x0a) {\n            buf = Buffer.from('.\\r\\n');\n        } else if (this.lastByte === 0x0d) {\n            buf = Buffer.from('\\n.\\r\\n');\n        } else {\n            buf = Buffer.from('\\r\\n.\\r\\n');\n        }\n        this.outByteCount += buf.length;\n        this.push(buf);\n        done();\n    }\n}\n\nmodule.exports = DataStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}